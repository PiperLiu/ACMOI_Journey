
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [模拟行走机器人 II（严谨思维）](#模拟行走机器人-ii严谨思维)
- [每一个查询的最大美丽值（二分）](#每一个查询的最大美丽值二分)
- [你可以安排的最多任务数目](#你可以安排的最多任务数目)

<!-- /code_chunk_output -->

T2 很考察严谨思维。

T3 二分但是还写了 20 分钟？基础差劲。

T4 乍一看题意很明确？我一下想到线性规划模型但这也不是编程的方法。思考很久不知道咋写。

### 模拟行走机器人 II（严谨思维）

![](./images/2021111301.png)

首先，可能会走很多圈，因此对经过一圈的步数取余就行，否则超时。

**注意在起点特殊，除了初始时刻，任何时候在起点都是朝向南的，初始时刻朝向东。**

```cpp
const string directions[4] = {"East", "North", "West", "South"};
const int dx[4] = {1, 0, -1, 0};
const int dy[4] = {0, 1, 0, -1};

class Robot {
public:
    int x, y, dir;
    int w, h;
    Robot(int width, int height) {
        x = 0;
        y = 0;
        w = width;
        h = height;
        dir = 0;
    }
    
    void move(int num) {
        if (num > 0 && num % ((w + h) * 2 - 4) == 0 && x == 0 && y == 0) dir = 3;  // 起点朝向特殊
        num %= ((w + h) * 2 - 4);
        for (int i = 0; i < num; ++ i)
        {
            if (x + dx[dir] < w && x + dx[dir] >= 0 && y + dy[dir] < h && y + dy[dir] >= 0)
            {
                x = x + dx[dir];
                y = y + dy[dir];
                continue;
            }
            dir = (dir + 1) % 4;
            if (x + dx[dir] < w && x + dx[dir] >= 0 && y + dy[dir] < h && y + dy[dir] >= 0)
            {
                x = x + dx[dir];
                y = y + dy[dir];
                continue;
            }
        }
    }

    vector<int> getPos() {
        return {x, y};
    }
    
    string getDir() {
        return directions[dir];
    }
};

/**
 * Your Robot object will be instantiated and called as such:
 * Robot* obj = new Robot(width, height);
 * obj->move(num);
 * vector<int> param_2 = obj->getPos();
 * string param_3 = obj->getDir();
 */
```

### 每一个查询的最大美丽值（二分）

![](./images/2021111302.png)

```cpp
class Solution {
public:
    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {
        int n = items.size();
        vector<int> ids = vector(n, 0);
        for (int i = 0; i < n; ++ i) ids[i] = i;
        auto cmp1 = [&](int a, int b) -> bool
        {
            return items[a][0] < items[b][0];
        };
        sort(ids.begin(), ids.end(), cmp1);
        
        int maxv = 0;
        vector<int> max_value = vector(n, 0);
        for (int i = 0; i < n; ++ i)
        {
            if (maxv < items[ids[i]][1])
                maxv = items[ids[i]][1];
            max_value[i] = maxv;
        }
        
        vector<int> res;
        for (auto&& q: queries)
        {
            int l = -1, r = n - 1, mid;
            while (l < r)
            {
                mid = l + r + 1 >> 1;
                if (items[ids[mid]][0] <= q) l = mid;
                else r = mid - 1;
            }
            if (l == -1)
                res.push_back(0);
            else res.push_back(max_value[l]);
        }
        return res;
    }
};
```

### 你可以安排的最多任务数目

![](./images/2021111303.png)

```cpp

```