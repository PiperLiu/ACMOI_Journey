
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [5194. 得到目标值的最少行动次数（贪心+逆向思维）](#5194-得到目标值的最少行动次数贪心逆向思维)
- [5982. 解决智力问题](#5982-解决智力问题)
- [5983. 同时运行 N 台电脑的最长时间](#5983-同时运行-n-台电脑的最长时间)

<!-- /code_chunk_output -->

低谷。很失落。努力了半年多，毫无成效。思维太窄了。 T2 完全想不到逆向思维，其实是很简单的事。但至少有经验了：以后 T2 完全不至于用 bfs 做。 T3 不知道错在哪。

看来只要是贪心题我就不会。

### 5194. 得到目标值的最少行动次数（贪心+逆向思维）

![](./images/leetcode-cn.com_contest_weekly-contest-276_problems_minimum-moves-to-reach-target-score_.png)

我的超时代码：
```cpp
#define fi first
#define se second

typedef pair<int, int> PII;  // value, cnt2
typedef pair<int, pair<int, int>> PIII;  // dist, {count2, value}

class Solution {
public:
    int minMoves(int target, int maxDoubles) {
        // set<PII> st;
        priority_queue<PIII, vector<PIII>, greater<PIII>> pq;
        pq.push({0, {0, 1}});
        // st.insert({1, 0});
        while (pq.size())
        {
            auto t = pq.top();
            pq.pop();
            int dist = t.fi, cnt2 = t.se.fi, value = t.se.se;
            // printf("%d %d %dok\n", dist, cnt2, value);
            if (value > target) continue;
            if (value == target) return dist;
            if (cnt2 == maxDoubles)
            {
                // printf("%d %d %d\n", dist, -cnt2, value * 2);
                pq.push({dist + (target - value), {-cnt2, target}});
            }
            else
            {
                // if (!st.count({value * 2, cnt2}))
                // {
                // printf("%d %d %d\n", dist, cnt2, value * 2);
                    pq.push({dist + 1, {cnt2 + 1, value * 2}});
                    // if (value * 2 != target) st.insert({value * 2, cnt2});
                // }
                // if (!st.count({value + 1, cnt2}))
                // {
                // printf("%d %d %d\n", dist, cnt2, value + 1);
                    pq.push({dist + 1, {cnt2, value + 1}});
                    // if (value + 1 != target) st.insert({value + 1, cnt2});
                // }
            }
        }
        
        return -1;
        
        // int cnt1 = 0, cnt2 = 0;
        // function<bool(int)> dfs = [&](int value) -> bool {
        //     if (value > target) return false;
        //     if (value == target) return true;
        //     if (cnt2 < maxDoubles)
        //     {
        //         cnt2 ++ ;
        //         if (dfs(value * 2)) return true;
        //         cnt2 -- ;
        //     }
        //     else
        //     {
        //         cnt1 ++ ;
        //         if (dfs(value + 1)) return true;
        //         cnt1 -- ;
        //     }
        //     return false;
        // };
        
        // dfs(1);
        // return cnt1 + cnt2;
    }
};
```

**正确思路：**

### 5982. 解决智力问题

![](./images/leetcode-cn.com_contest_weekly-contest-276_problems_solving-questions-with-brainpower_.png)

我的错误代码：

```cpp
#define fi first
#define se second

class Solution {
public:
    long long mostPoints(vector<vector<int>>& questions) {
        int n = questions.size();
        vector<pair<long long, int>> dp(n + 1, {0L, 0});
        
        function<pair<long long, int>(int)> dfs = [&](int m) -> pair<long long, int>
        {
            if (m == 0) return {0L, 0};
            if (dp[m].se != 0) return dp[m];
            auto last = dfs(m - 1);
            long long maxv = last.fi;
            int step = last.se;
            if (step <= 0)
            {
                dp[m] = {maxv + questions[m - 1][0], questions[m - 1][1]};
                return dp[m];
            }
            int k = 1;
            while (step >= k)
            {
                ++ k;
                auto t = dfs(m - k);
                maxv = t.fi;
                step = t.se;
            }

            if (maxv + questions[m - 1][0] > last.fi)
                dp[m] = {maxv + questions[m - 1][0], questions[m - 1][1]};
            else
                dp[m] = {last.fi, last.se - 1};
            return dp[m];
        };

        dfs(n);
        
        for (int i = 0; i <= n; ++ i)
            cout << dp[i].fi << " " << dp[i].se << endl;

        return dp[n].fi;
    }
};
```

```
正确：
[[3,2],[4,3],[4,4],[2,5]]
[[1,1],[2,2],[3,3],[4,4],[5,5]]
输出：
5
7

错误：
[[21,2],[1,2],[12,5],[7,2],[35,3],[32,2],[80,2],[91,5],[92,3],[27,3],[19,1],[37,3],[85,2],[33,4],[25,1],[91,4],[44,3],[93,3],[65,4],[82,3],[85,5],[81,3],[29,2],[25,1],[74,2],[58,1],[85,1],[84,2],[27,2],[47,5],[48,4],[3,2],[44,3],[60,5],[19,2],[9,4],[29,5],[15,3],[1,3],[60,2],[63,3],[79,3],[19,1],[7,1],[35,1],[55,4],[1,4],[41,1],[58,5]]
输出：737
预期：781
```

### 5983. 同时运行 N 台电脑的最长时间

![](./images/leetcode-cn.com_contest_weekly-contest-276_problems_maximum-running-time-of-n-computers_.png)
