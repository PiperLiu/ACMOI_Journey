
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [找出 3 位偶数（思维严谨）](#找出-3-位偶数思维严谨)
- [从二叉树一个节点到另一个节点每一步的方向（思维题/反套路）](#从二叉树一个节点到另一个节点每一步的方向思维题反套路)
- [合法重新排列数对](#合法重新排列数对)

<!-- /code_chunk_output -->

T1 就因为思维不严谨调了18分钟？经验不足。因此好好记录一下。

T3 给我提了个大醒，别陷入模板套路！我最先想到 `dfs + dijkstra` ，实际上根本不用，稍微对着样例思考下过程就能发现规律...罚时完全是因为自己傻了，非常低级的失误。

### 找出 3 位偶数（思维严谨）

![](./images/leetcode-cn.com_contest_weekly-contest-270_problems_finding-3-digit-even-numbers_.png)

```cpp
class Solution {
public:
    vector<int> findEvenNumbers(vector<int>& digits) {
        sort(digits.begin(), digits.end());
        int n = digits.size();
        
        int lasti = -1, lastj = -1, lastk = -1;
        
        vector<int> res;
        for (int i = 0; i < n; ++ i)
        {
            if (digits[i] == lasti)
                continue;
            if (digits[i] == 0) continue;
            lasti = digits[i];
            lastj = -1;
            for (int j = 0; j < n; ++ j)
            {
                // if (digits[j] == 2) cout << i << " " << j << " " << endl;
                if (digits[j] == lastj)
                    continue;
                if (j == i) continue;
                lastj = digits[j];
                lastk = -1;
                for (int k = 0; k < n; ++ k)
                {
                    // cout << i << " " << j << " " << k << endl;
                    if (digits[k] == lastk)
                        continue;
                    if (j == k || i == k) continue;
                    if (digits[k] % 2) continue;
                    lastk = digits[k];
                    res.push_back(digits[i] * 100 + digits[j] * 10 + digits[k]);
                }
            }
        }
        
        return res;
    }
};
```

### 从二叉树一个节点到另一个节点每一步的方向（思维题/反套路）

![](./images/leetcode-cn.com_contest_weekly-contest-270_problems_step-by-step-directions-from-a-binary-tree-node-to-another_.png)

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

class Solution {
public:
    string getDirections(TreeNode* root, int startValue, int destValue) {
        
        string staPath, desPath, path;

        function<void(TreeNode*)> dfs = [&](TreeNode* u)
        {
            if (!u) return ;
            if (u->val == startValue) staPath = path;
            if (u->val == destValue) desPath = path;

            TreeNode* l = u->left;
            TreeNode* r = u->right;

            if (l)
            {
                path += 'L';
                dfs(l);
                path.pop_back();
            }
            
            if (r)
            {
                path += 'R';
                dfs(r);
                path.pop_back();
            }
        };

        dfs(root);
        
        int i = 0;
        for (; i < staPath.size() && i < desPath.size() && staPath[i] == desPath[i]; ++ i);
        
        staPath = staPath.substr(i);
        desPath = desPath.substr(i);

        string front(staPath.size(), 'U');
        string res = front + desPath;
        return res;
    }
};
```

### 合法重新排列数对

![](./images/leetcode-cn.com_contest_weekly-contest-270_problems_valid-arrangement-of-pairs_.png)

```cpp

```
