<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1875. 贝茜的报复（发现规律+取补集）](#1875-贝茜的报复发现规律取补集)
- [简单题不详记](#简单题不详记)

<!-- /code_chunk_output -->

### 1875. 贝茜的报复（发现规律+取补集）

农夫约翰和奶牛贝茜喜欢在业余时间互相出数学题。

约翰给贝茜出了一道相当难的问题，导致她没能解决。

现在，她希望通过给约翰出一道有挑战性的难题来报复他。

贝茜给了约翰一个表达式 $(B+E+S+S+I+E)(G+O+E+S)(M+O+O)$，其中包含七个变量 $B,E,S,I,G,O,M$（$O$ 是变量，不是零）。

对于每个变量，她给约翰一个列表，表中包含该变量可采用的最多 $20$ 个整数值。

她要求约翰计算，共有多少种给变量赋值的方法可以使得表达式的计算结果偶数。

<h4>输入格式</h4>

第一行包含一个整数 $N$。

接下来 $N$ 行，每行包含一个变量和该变量的一个可能值。

每个变量至少出现 $1$ 次，最多出现 $20$ 次。

同一变量不会重复列出同一可能值。

<h4>输出格式</h4>

输出可以使得表达式的计算结果是偶数的给变量赋值的方法总数。

<h4>数据范围</h4>

- $7 \le N \le 140$,
- 所有变量的可能取值范围 $[−300,300]$

<h4>输入样例：</h4>

```
10
B 2
E 5
S 7
I 10
O 16
M 19
B 3
G 1
I 9
M 2
```

<h4>输出样例：</h4>

```
6
```

<h4>样例解释</h4>

共有 $6$ 种可能的赋值方式：

```
(B,E,S,I,G,O,M) = (2, 5, 7, 10, 1, 16, 19) -> 53,244
                = (2, 5, 7, 10, 1, 16, 2 ) -> 35,496
                = (2, 5, 7, 9,  1, 16, 2 ) -> 34,510
                = (3, 5, 7, 10, 1, 16, 2 ) -> 36,482
                = (3, 5, 7, 9,  1, 16, 19) -> 53,244
                = (3, 5, 7, 9,  1, 16, 2 ) -> 35,496
```

注意，`(2, 5, 7, 10, 1, 16, 19)` 和 `(3, 5, 7, 9,  1, 16, 19)`，虽然计算结果相同，但是赋值方式不同，所以要分别计数。

我的代码：

```cpp
/**
 * 三项中至少有一个是偶数 -> 全部情况 减去 全为奇数的情况
 * 一是偶数：B I 不能奇偶性不同
 * 二是偶数：G O E S 中奇数数量不能为单数
 * 三是偶数：M 不能是奇数
 */
#include <iostream>
#include <cstring>
#include <algorithm>
#include <unordered_map>
#include <vector>

using namespace std;

int main()
{
    unordered_map<char, vector<int>> j, o;
    int n;
    cin >> n;
    for (int i = 0; i < n; ++ i)
    {
        char c;
        int a;
        cin >> c >> a;
        if (a % 2) j[c].push_back(a);
        else o[c].push_back(a);
    }
    
    long long tot = 1;
    for (auto&& item: j) tot *= (item.second.size() + o[item.first].size());

    // B I 中仅仅一个是奇数
    long long sub1 = 0, sub2 = 0, sub3 = 0;
    sub1 += (j['B'].size() * o['I'].size()) + (o['B'].size() * j['I'].size());

    // G O E S 中奇数数量为 1 或 3
    char dc[4] = {'G', 'O', 'E', 'S'};
    for (int i = 0; i < 4; ++ i)
    {
        char c = dc[i];
        // 计算 1 偶 3 奇的情况
        long long temp = 1;
        for (int k = 0; k < 4; ++ k)
            if (k != i)
                temp *= j[dc[k]].size();
        sub2 += o[c].size() * temp;
        // 计算 1 奇 3 偶的情况
        temp = 1;
        for (int k = 0; k < 4; ++ k)
            if (k != i)
                temp *= o[dc[k]].size();
        sub2 += j[c].size() * temp;
    }

    // M 是奇数
    sub3 += j['M'].size();

    tot -= sub1 * sub2 * sub3;

    cout << tot << endl;
}
```

### 简单题不详记
