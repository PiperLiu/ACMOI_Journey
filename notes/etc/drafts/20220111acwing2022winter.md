<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1987. 粉刷栅栏（差分+离散化）](#1987-粉刷栅栏差分离散化)
- [1978. 奶牛过马路（前缀和最值/双向遍历）](#1978-奶牛过马路前缀和最值双向遍历)
- [品种邻近（哈希表/滑动窗口）](#品种邻近哈希表滑动窗口)

<!-- /code_chunk_output -->

### 1987. 粉刷栅栏（差分+离散化）

农夫约翰发明了一种绝妙的方法来粉刷牛棚旁边的长栅栏（把栅栏想象成一维的数轴）。

他只需要在他最喜欢的奶牛贝茜身上挂一个刷子，然后在一旁悠闲的喝凉水就行了。

贝茜沿着栅栏来回走动时，会将她走过的栅栏部分涂上油漆。

贝茜从栅栏上的位置 $0$ 处开始，共进行 $N$ 次移动。

移动可能形如 `10 L`，表示向左移动 $10$ 单位距离，也可能形如 `15 R`，表示向右移动 $15$ 单位距离。

给定贝茜的 $N$ 次移动列表，约翰想知道至少被涂抹了 $2$ 层油漆的区域的总长度。

整个行进过程中，贝茜距离出发地的距离不会超过 $10^9$。

<h4>输入格式</h4>

第一行包含一个整数 $N$。

接下来 $N$ 行，每一行包含一个行动指令，诸如 `10 L` 或 `15 R`。

<h4>输出格式</h4>

输出至少被涂抹了 $2$ 层油漆的区域的总长度。

<h4>数据范围</h4>

- $1 \le N \le 10^5$
- 整个行进过程中，贝茜距离出发地的距离不会超过 $10^9$。
- 每次指令移动距离的取值范围是 $[1,2 \times 10^9]$。

<h4>输入样例：</h4>

```
6
2 R
6 L
1 R
8 L
1 R
2 R
```

<h4>输出样例：</h4>

```
6
```

<h4>样例解释</h4>

共有 $6$ 单位长度的区域至少被涂抹 $2$ 层油漆。

这些区域为 $(-11,-8), (-4,-3), (0,2)$。

```cpp
/**
 * 差分记录变化
 * 数值大于等于 2 的区域长度加进 ans
 */
#include <iostream>
#include <cstring>
#include <algorithm>
#include <map>
using namespace std;

map<int, int> diff;

int main()
{
    int n;
    cin >> n;
    int x = 0;
    for (int i = 0; i < n; ++ i)
    {
        char o;
        int d;
        cin >> d >> o;
        if (o == 'R') d = - d;
        int newx = x + d;
        diff[min(newx, x)] ++ ;
        diff[max(newx, x)] -- ; 
        x = newx;
    }

    // 差分转数值
    int ans = 0;
    int s = 0, p = -2e9;
    for (auto&& [k, v]: diff)
    {
        if (s > 1) ans += (k - p);
        s = s + v;
        p = k;
    }
    
    cout << ans << endl;
}
```

### 1978. 奶牛过马路（前缀和最值/双向遍历）

每天，农夫约翰的 $N$ 头奶牛都会穿过农场中间的马路。

考虑约翰的农场在二维平面的地图，马路沿水平方向延伸，马路的一侧由直线 $y=0$ 描述，另一侧由直线 $y=1$ 描述。

奶牛 $i$ 从马路一侧的位置 $(a_i,0)$ 沿直线过马路到达另一侧的位置 $(b_i,1)$。

所有 $a_i$ 互不相同，所有 $b_i$ 互不相同。

尽管他的奶牛们行动敏捷，他还是担心行动路径交叉的两头奶牛在过马路时发生碰撞。

约翰认为，如果一头奶牛的行动路径没有跟其他任何奶牛的行动路径相交，则该奶牛是安全的。

请帮助约翰计算安全奶牛的数量。

<h4>输入格式</h4>

第一行包含整数 $N$。

接下来 $N$ 行，每行包含两个整数 $a_i,b_i$，用来描述一头牛的行动路径。

<h4>输出格式</h4>

输出安全奶牛的数量。

<h4>数据范围</h4>

- $1 \le N \le 10^5$,
- $-10^6 \le a_i,b_i \le 10^6$

<h4>输入样例：</h4>

```
4
-3 4
7 8
10 16
3 9
```

<h4>输出样例：</h4>

```
2
```

<h4>样例解释</h4>

第一头牛和第三头牛的行动路线不与其他奶牛的路线相交。

第二头牛和第四头牛的行动路线相交。

```cpp
/**
 * (ai, bi)
 * 按照 ai 排序
 * 如果 i 不与其他线段相交，当且仅当
 * bi 大于 max(b1, ..., b_{i-1})
 * bi 小于 min(b_{i+1}, ..., bn)
 */
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

typedef pair<int, int> PII;

const int N = 1e5 + 10;
int Smax[N], Smin[N];
PII a[N];

int main()
{
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n; ++ i) scanf("%d %d", &a[i].first, &a[i].second);
    
    sort(a + 1, a + n + 1);
    
    Smax[0] = -2e9;
    for (int i = 1; i <= n; ++ i) Smax[i] = max(Smax[i - 1], a[i].second);

    Smin[n + 1] = 2e9;
    for (int i = n; i >= 1; -- i) Smin[i] = min(Smin[i + 1], a[i].second);

    int res = 0;
    for (int i = 1; i <= n; ++ i)
        if (a[i].second > Smax[i - 1] && a[i].second < Smin[i + 1])
            ++ res;
    
    printf("%d\n", res);
}
```

### 品种邻近（哈希表/滑动窗口）

农夫约翰的 $N$ 头奶牛排成一排，每头奶牛都用其品种 $ID$ 进行描述。

如果两头相同品种的牛靠得太近，它们就会吵架。

具体的说，如果同一品种的两头奶牛在队列中的位置相差不超过 $K$，我们就称这是一对拥挤的牛。

请计算品种 $ID$ 最大的拥挤奶牛对的品种 $ID$。

<h4>输入格式</h4>

第一行包含两个整数 $N$ 和 $K$。

接下来 $N$ 行，每行包含一个整数表示队列中一头奶牛的品种 $ID$。

<h4>输出格式</h4>

输出品种 $ID$ 最大的拥挤奶牛对的品种 $ID$。

如果不存在拥挤奶牛队，则输出 $-1$。

<h4>数据范围</h4>

- $1 \le N \le 50000$,
- $1 \le K < N$,
- 品种 $ID$ 范围 $[0,10^6]$。

<h4>输入样例：</h4>

```
6 3
7
3
4
2
3
4
```

<h4>输出样例：</h4>

```
4
```

<h4>样例解释</h4>

一对品种 $ID$ 为 $3$ 的奶牛以及一对品种 $ID$ 为 $4$ 的奶牛属于拥挤奶牛对。

所以，最大拥挤奶牛对的品种 $ID$ 为 $4$。

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <map>
using namespace std;

map<int, int> id2pos;

int main()
{
    int n, k;
    cin >> n >> k;
    int res = -1;
    for (int i = 0; i < n; ++ i)
    {
        int id;
        cin >> id;
        if (!id2pos.count(id)) id2pos[id] = i;
        else
        {
            if (i - id2pos[id] <= k) res = max(res, id);
            id2pos[id] = i;
        }
    }
    cout << res << endl;
}
```

如上，我是用枚举做的。

y 总用滑动窗口做的。

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>

using namespace std;

const int M = 1000010;

int n, k;
int cnt[M];

int main()
{
    scanf("%d%d", &n, &k);

    int res = -1;
    queue<int> q;
    for (int i = 0; i < n; i ++ )
    {
        int id;
        scanf("%d", &id);

        if (cnt[id] > 0) res = max(res, id);
        cnt[id] ++ ;
        q.push(id);
        if (q.size() > k)
        {
            cnt[q.front()] -- ;
            q.pop();
        }
    }

    printf("%d\n", res);
    return 0;
}
```
