<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [格雷编码（格雷码/镜面找规律/背公式）](#格雷编码格雷码镜面找规律背公式)
- [306. 累加数（分析/高精度/考察逻辑清晰）](#306-累加数分析高精度考察逻辑清晰)
- [1036. 逃离大迷宫（有限步数BFS/离散化BFS）](#1036-逃离大迷宫有限步数bfs离散化bfs)

<!-- /code_chunk_output -->

### 格雷编码（格雷码/镜面找规律/背公式）

https://leetcode-cn.com/problems/gray-code

$n$ 位格雷码序列 是一个由 $2n$ 个整数组成的序列，其中：
- 每个整数都在范围 $[0, 2n - 1]$ 内（含 $0$ 和 $2n - 1$）
- 第一个整数是 $0$
- 一个整数在序列中出现 不超过一次
- 每对 相邻 整数的二进制表示 恰好一位不同 ，且
- 第一个 和 最后一个 整数的二进制表示 恰好一位不同
- 给你一个整数 $n$ ，返回任一有效的 $n$ 位格雷码序列 。

```
输入：n = 2
输出：[0,1,3,2]
解释：
[0,1,3,2] 的二进制表示是 [00,01,11,10] 。
- 00 和 01 有一位不同
- 01 和 11 有一位不同
- 11 和 10 有一位不同
- 10 和 00 有一位不同
[0,2,3,1] 也是一个有效的格雷码序列，其二进制表示是 [00,10,11,01] 。
- 00 和 10 有一位不同
- 10 和 11 有一位不同
- 11 和 01 有一位不同
- 01 和 00 有一位不同
```

```
输入：n = 1
输出：[0,1]
```

提示：
- $1 \le n \le 16$

参考：
- https://leetcode-cn.com/problems/gray-code/solution/ge-lei-bian-ma-by-leetcode-solution-cqi7/
- https://leetcode-cn.com/u/qian-ikong/

**方法一：对称生成**

假设我们已经获取到 $n-1$ 位的格雷码序列 $G_{n-1}$，我们只需要将 $G_{n-1}$ 对称翻转，记作 $G_{n-1}^T$ 。$G_{n-1}$ 的首元素和 $G_{n-1}^T$ 的尾元素都是相同的，反之亦然。如果我们给 $G_{n-1}^T$ 的每个元素都加上 $2^{n-1}$ ，记作 $(G_{n-1}^T)'$，则 $G_{n-1}$ 的首元素和 $(G_{n-1}^T)'$ 的尾元素只有一位不相同，反之亦然。因此 $G_{n-1}$ 和 $(G_{n-1}^T)'$ 拼接的序列 $G_n=[G_{n-1},~(G_{n-1}^T)']$ 满足 $n$ 位的格雷码的定义。初始值 $G_0 = [0]$。

人话解释：

```
n = 1  [0, 1]
n = 2  [00，01，11，10]
n = 3  [000, 001, 011, 010, 110, 111, 101, 100]
....
```

一位格雷码只有两个元素，`[1， 0]`

因为格雷码 `n` 每增加 `1` ，包含的数字会翻倍，这里我们设 `n` 位格雷码包含 `c` 个数，前一个 `n` 为 `n'` ，所以` c = 2c'`

所以这时 `n` 中的前 `c'` 个数是 `n'` 中的所有数字前面补 `0` ，相当于全部都是 `n'` 中的数字

```
n = 2  [ 00,  01,  11,  10] 
n = 3  [000, 001, 011, 010] (前四个数)
```

这时 `n` 中的后 `c'` 个数是 `n'` 中的所有数字前面补 `1` ，然后变为逆序

```
n = 2  [ 00,  01,  11,  10] 
       [100, 101, 111, 110]  补 1
       [110, 111, 101, 100] （后四个数逆序）
```

结果拼接

```
n = 3  [000, 001, 011, 010, 110, 111, 101, 100]
```

```cpp
class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> ret;
        ret.push_back(0);
        for (int i = 1; i <= n; ++ i)
        {
            int m = ret.size();
            for (int j = m - 1; j >= 0; -- j)
                ret.push_back(ret[j] | (1 << (i - 1)));  // 异或就是填补 0 位
        }
        return ret;
    }
};
```

时间复杂度：$O(2^n)$，其中 $n$ 为格雷码序列的位数。递推过程的时间复杂度为 $O(\sum_{i=1}^n 2^{i-1})=O(2^n)$。

空间复杂度：$O(1)$。注意返回值不计入空间复杂度。

**方法二：二进制数转格雷码**

如果我们有一个二进制数序列，我们也可以将它直接转换成格雷码序列。假设 $n$ 位二进制数为 $b$ ，对应的格雷码为 $g$ ，转换规则如下：

$$
g(i) = b(i+1) \oplus b(i),~~~~0 \le i \lt n
$$

其中 $\oplus$ 是按位异或运算，$g(i)$ 和 $b(i)$ 分别表示 $g$ 和 $b$ 的第 $i$ 位，且 $b(n)=0$ 。

上述转换规则的证明如下：

考虑 $n$ 位二进制数 $b_i$ 和对应的转换码 $g_i$，并且 $b_{i+1} = b_i + 1$ 也是 $n$ 位二进制数。$b_{i+1}$ 与 $b_i$ 的区别在于 $b_{i+1}$ 将 $b_i$ 二进制下末位连接的 $1$ 全部变成 $0$ ，然后将最低位的 $0$ 变成 $1$ 。

假设变化涉及到的二进制位数为 $k$ 位，则按照上述转换规则（$g(i) = b(i+1) \oplus b(i)$）， $g_{i+1}$ 与 $g_{i}$ 只有在第 $k - 1$ 位不相同，其他位都相同。因此转换得到的码相邻的数只有一位不同，而转换码第一个整数和最后一个整数分别由二进制数 $0$ 和 $2^n-1$ 转换而来，也只有一位不同。因为二进制数的取值范围为 $[0,~2^n)$，且上述转换规则为一对一映射，因此得到的转换码也是互不相同的，且取值范围也在 $[0,~2^n)$，得证。

我有两个问题：
- 如何更好地说明 $g_{i+1}$ 与 $g_{i}$ 只有在第 $k - 1$ 位不相同 ？
- 如何证明 `上述转换规则为一对一映射` ？

方法二人话解释：

不管`n`为几，当前n的格雷码中的前一半始终为`n - 1`的全部，所以这时我们可以忽略n在格雷码中的影响

这时我们将格雷码编号：

```
[000, 001, 011, 010, 110, 111, 101, 100 ...]
  0,   1,   2,   3 ,   4,   5,  6,   7,  ...
```

这里的`0 ~ 7..`. 转换为二进制后我们成为二进制码，比如我们要求解5对应的格雷码，这里`5`对应的二进制码就是`0101`（`4`的二进制）
二进制码对应的每一位就是小`b`，，格雷码每一位是`g`，这里讲解过程中在前面补`0`方便理解，这里的`\/`就是异或的运算

```
0   0   1   0   1
0   b3  b2  b1  b0
  \/  \/  \/  \/ 
  g3  g2  g1  g0
   0   1   1   1
```

所以我们由`5`（`0101`）推出对应的格雷码为`0111`

这里解释一下 `(i >> 1) ^ i，i>>1` 其实将`i`每一位向后移动一位，这时和`i`取异或，相当于和自己的后一位取余

```
b3 b2  b1  b0  (i)
0  b3  b2  b1  (i >> 1)
g3 g2  g1  g0  (结果) 
```

```cpp
class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> ret(1 << n);
        for (int i = 0; i < 1 << n; ++ i)
            ret[i] = (i >> 1) ^ i;
        return ret;
    }
};
```

时间复杂度：$O(2^n)$，其中 $n$ 为格雷码序列的位数。每个整数转换为格雷码的时间复杂度为 $O(1)$，总共有 $2^n$ 个转换。

空间复杂度：$O(1)$。注意返回值不计入空间复杂度。

### 306. 累加数（分析/高精度/考察逻辑清晰）

累加数是一个字符串，组成它的数字可以形成累加序列。

一个有效的 累加序列 必须 至少 包含 3 个数。除了最开始的两个数以外，字符串中的其他数都等于它之前两个数相加的和。

给你一个只包含数字`'0'-'9'`的字符串，编写一个算法来判断给定输入是否是 累加数 。如果是，返回 `true` ；否则，返回 `false` 。

说明：累加序列里的数 不会 以 `0` 开头，所以不会出现`1, 2, 03 或者`1, 02, 3`的情况。

示例 1：
```
输入："112358"
输出：true 
解释：累加序列为: 1, 1, 2, 3, 5, 8 。1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8
```

示例 2：
```
输入："199100199"
输出：true 
解释：累加序列为: 1, 99, 100, 199。1 + 99 = 100, 99 + 100 = 199
```

提示：
- $1 \le num.length \le 35$
- num 仅由数字（`0 - 9`）组成

```cpp
class Solution {
/**
 *  重点：当第一个数和第二个数确定了，后面的也就确定了
 *  所以枚举第一个和第二个数就行
 */
public:
    bool isAdditiveNumber(string num) {
        int n = num.size();
        for (int secondStart = 1; secondStart < n - 1; ++secondStart) {
            if (num[0] == '0' && secondStart != 1) {
                return false;  // 第一个数是 0pppp 不行
            }
            for (int secondEnd = secondStart; secondEnd < n - 1; ++secondEnd) {
                if (num[secondStart] == '0' && secondStart != secondEnd) {
                    break;  // 第二数有前导零，不行
                }
                if (valid(secondStart, secondEnd, num)) {
                    return true;
                }
            }
        }
        return false;
    }

    bool valid(int secondStart, int secondEnd, string num) {
        int n = num.size();
        int firstStart = 0, firstEnd = secondStart - 1;
        while (secondEnd <= n - 1) {
            // 下面验证第三个数（数值已定，找位置）
            string third = stringAdd(num, firstStart, firstEnd, secondStart, secondEnd);
            int thirdStart = secondEnd + 1;
            int thirdEnd = secondEnd + third.size();
            if (thirdEnd >= n || !(num.substr(thirdStart, thirdEnd - thirdStart + 1) == third)) {
                break;
            }
            if (thirdEnd == n - 1) {
                return true;
            }
            firstStart = secondStart;
            firstEnd = secondEnd;
            secondStart = thirdStart;
            secondEnd = thirdEnd;
        }
        return false;
    }

    string stringAdd(string s, int firstStart, int firstEnd, int secondStart, int secondEnd) {
        string third;
        int carry = 0, cur = 0;
        while (firstEnd >= firstStart || secondEnd >= secondStart || carry != 0) {
            cur = carry;
            if (firstEnd >= firstStart) {
                cur += s[firstEnd] - '0';
                --firstEnd;
            }
            if (secondEnd >= secondStart) {
                cur += s[secondEnd] - '0';
                --secondEnd;
            }
            carry = cur / 10;
            cur %= 10;
            third.push_back(cur + '0');
        }
        reverse(third.begin(), third.end());
        return third;
    }
};
```

### 1036. 逃离大迷宫（有限步数BFS/离散化BFS）

在一个 $10^6 \times 10^6$ 的网格中，每个网格上方格的坐标为 `(x, y)` 。

现在从源方格 `source = [sx, sy]` 开始出发，意图赶往目标方格 `target = [tx, ty]` 。数组 blocked 是封锁的方格列表，其中每个 `blocked[i] = [xi, yi]` 表示坐标为 `(xi, yi)` 的方格是禁止通行的。

每次移动，都可以走到网格中在四个方向上相邻的方格，只要该方格 不 在给出的封锁列表 `blocked` 上。同时，不允许走出网格。

只有在可以通过一系列的移动从源方格 `source` 到达目标方格 `target` 时才返回 `true` 。否则，返回 `false`。

示例 1：
```
输入：blocked = [[0,1],[1,0]], source = [0,0], target = [0,2]
输出：false
解释：
从源方格无法到达目标方格，因为我们无法在网格中移动。
无法向北或者向东移动是因为方格禁止通行。
无法向南或者向西移动是因为不能走出网格。
```

示例 2：
```
输入：blocked = [], source = [0,0], target = [999999,999999]
输出：true
解释：
因为没有方格被封锁，所以一定可以到达目标方格。
```

提示：
- 0 <= blocked.length <= 200
- blocked[i].length == 2
- 0 <= $x_i, y_i$ < 106
- source.length == target.length == 2
- 0 <= $s_x, s_y, t_x, t_y$ < 106
- source != target

题目数据保证 `source` 和 `target` 不在封锁列表内。

分析主要参考 [LeetCode](https://leetcode-cn.com/problems/escape-a-large-maze/solution/tao-chi-da-mi-gong-by-leetcode-solution-qxhz/) ：

**方法一：有限步数的广度优先搜索**

判断能否从 $\textit{source}$ 走到 $\textit{target}$ ，最简单且直观的方法就是从 $\textit{source}$ 开始进行广度优先搜索，如果搜索的过程中经过了 $\textit{target}$ ，则说明可以到达。

然而本题中给定的网格规模是 $10^6 \times 10^6$ 的，常规的广度优先搜索会达到 $O(10^6 \times 10^6) = O(10^{12})$ 的时间复杂度，远远超出了时间限制。因此我们必须进行优化。

注意到障碍的个数不超过 $200$ 个，这说明网格中大部分的位置都不是障碍，只有极少一部分的位置是障碍。分析从 $\textit{source}$ 无法走到 $\textit{target}$ 的情况，无非就是以下两种：

- $\textit{source}$ 被障碍完全包围，并且 $\textit{target}$ 不在包围圈中；
- $\textit{target}$ 被障碍完全包围，并且 $\textit{source}$ 不在包围圈中。

在「障碍的个数不超过 $200$ 个前提下」，我们可以猜测「包围圈」的大小也不会很大。也就是说，如果障碍的个数为 $n$ 个，那么我们希望得到「包围圈」中包含的非障碍位置的数量的上界，假设其为 $\textit{limit}$，那么：

如果我们从 source 开始进行广度优先搜索，搜索到的非障碍位置的数量严格大于 limit，那么说明 source 一定不在任何包围圈中。同时，如果从 target 开始进行广度优先搜索也是如此，那么同样说明 target 一定也不在任何包围圈中。此时我们就可以断定，一定能从 source 走到 target。

这里省去一个证明：障碍圈和包围线围起来的最多的非障碍格子数量为 $\frac{n(n - 1)}{2}$ 。

其中 $n$ 为障碍物数量。

因此我们的做法可行。

```cpp
class Solution {
private:
    // 在包围圈中
    static constexpr int BLOCKED = -1;
    // 不在包围圈中
    static constexpr int VALID = 0;
    // 无论在不在包围圈中，但在 n(n-1)/2 步搜索的过程中经过了 target
    static constexpr int FOUND = 1;
    
    static constexpr int dirs[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    static constexpr int BOUNDARY = 1000000;

public:
    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {
        if (blocked.size() < 2) {
            return true;
        }

        auto hash_fn = [fn = hash<long long>()](const pair<int, int>& o) -> size_t {
            auto& [x, y] = o;
            return fn((long long)x << 20 | y);
        };  // 确定元素存储位置所用的哈希函数
        unordered_set<pair<int, int>, decltype(hash_fn)> hash_blocked(0, hash_fn);
        for (const auto& pos: blocked) {
            hash_blocked.emplace(pos[0], pos[1]);
        }

        auto check = [&](vector<int>& start, vector<int>& finish) -> int {
            int sx = start[0], sy = start[1];
            int fx = finish[0], fy = finish[1];
            int countdown = blocked.size() * (blocked.size() - 1) / 2;  // 有限步数
            queue<pair<int, int>> q;
            q.emplace(sx, sy);
            unordered_set<pair<int, int>, decltype(hash_fn)> visited(0, hash_fn);
            visited.emplace(sx, sy);
            while (!q.empty() && countdown > 0) {
                auto [x, y] = q.front();
                q.pop();
                for (int d = 0; d < 4; ++d) {
                    int nx = x + dirs[d][0], ny = y + dirs[d][1];
                    if (nx >= 0 && nx < BOUNDARY && ny >= 0 && ny < BOUNDARY && !hash_blocked.count({nx, ny}) && !visited.count({nx, ny})) {
                        if (nx == fx && ny == fy) {
                            return FOUND;
                        }
                        --countdown;
                        q.emplace(nx, ny);
                        visited.emplace(nx, ny);
                    }
                }
            }
            if (countdown > 0) {
                return BLOCKED;
            }
            return VALID;
        };

        if (int result = check(source, target); result == FOUND) {
            return true;
        }
        else if (result == BLOCKED) {
            return false;
        }
        else {
            result = check(target, source);
            if (result == BLOCKED) {
                return false;
            }
            return true;
        }
    }
};
```

**方法二：离散化 + 广度优先搜索**

我们也可以借助离散化技巧将网格「压缩」成一个规模较小的但等价的新网格，并在新网格上进行常规的广度优先搜索。

以网格的每一行为例，可以发现，不同的行坐标只有：

障碍所在的行，最多有 $n$ 个；

$\textit{source}$ 和 $\textit{target}$ 所在的行，最多有 2 个。

网格的上下边界（即 -1 和 $10^6$ ），有 2 个。

因此不同的行坐标最多只有 $n+4$ 个，我们可以对行坐标进行离散化，具体的规则如下：

- 我们将行坐标进行升序排序；
- 将上边界离散化为 -1。上边界是排序后的第 0 个行坐标；
- 如果排序后的第 i 个行坐标与第 i-1 个行坐标相同，那么它们离散化之后的值也相同；
- 如果排序后的第 i 个行坐标与第 i-1 个行坐标相差 1，那么它们离散化之后的值也相差 1；
- 如果排序后的第 i 个行坐标与第 i−1 个行坐标相差超过 1，那么它们离散化之后的值相差 2。

这样的正确性在于：在离散化前，如果两个行坐标本身相邻，那么在离散化之后它们也必须相邻。如果它们不相邻，可以把它们之间间隔的若干行直接「压缩」成一行，即行坐标相差 2。

对于列坐标的离散化方法也是如此。在离散化完成之后，新的网格的规模不会超过 $2(n+4) \times 2(n+4)$ ，进行广度优先搜索需要的时间是可接受的。

```cpp
class Solution {
private:
    static constexpr int BOUNDARY = 1000000;
    static constexpr int dirs[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    
public:
    bool isEscapePossible(vector<vector<int>>& blocked, vector<int>& source, vector<int>& target) {
        if (blocked.size() < 2) {
            return true;
        }
        vector<int> rows, columns;
        for (const auto& pos: blocked) {
            rows.push_back(pos[0]);
            columns.push_back(pos[1]);
        }
        rows.push_back(source[0]);
        rows.push_back(target[0]);
        columns.push_back(source[1]);
        columns.push_back(target[1]);
        
        // 离散化
        sort(rows.begin(), rows.end());
        sort(columns.begin(), columns.end());
        rows.erase(unique(rows.begin(), rows.end()), rows.end());
        columns.erase(unique(columns.begin(), columns.end()), columns.end());
        unordered_map<int, int> r_mapping, c_mapping;

        int r_id = (rows[0] == 0 ? 0 : 1);
        r_mapping[rows[0]] = r_id;
        for (int i = 1; i < rows.size(); ++i) {
            r_id += (rows[i] == rows[i - 1] + 1 ? 1 : 2);
            r_mapping[rows[i]] = r_id;
        }
        if (rows.back() != BOUNDARY - 1) {
            ++r_id;
        }

        int c_id = (columns[0] == 0 ? 0 : 1);
        c_mapping[columns[0]] = c_id;
        for (int i = 1; i < columns.size(); ++i) {
            c_id += (columns[i] == columns[i - 1] + 1 ? 1 : 2);
            c_mapping[columns[i]] = c_id;
        }
        if (columns.back() != BOUNDARY - 1) {
            ++c_id;
        }

        vector<vector<int>> grid(r_id + 1, vector<int>(c_id + 1));
        for (const auto& pos: blocked) {
            int x = pos[0], y = pos[1];
            grid[r_mapping[x]][c_mapping[y]] = 1;
        }
        
        int sx = r_mapping[source[0]], sy = c_mapping[source[1]];
        int tx = r_mapping[target[0]], ty = c_mapping[target[1]];

        queue<pair<int, int>> q;
        q.emplace(sx, sy);
        grid[sx][sy] = 1;
        while (!q.empty()) {
            auto [x, y] = q.front();
            q.pop();
            for (int d = 0; d < 4; ++d) {
                int nx = x + dirs[d][0], ny = y + dirs[d][1];
                if (nx >= 0 && nx <= r_id && ny >= 0 && ny <= c_id && grid[nx][ny] != 1) {
                    if (nx == tx && ny == ty) {
                        return true;
                    }
                    q.emplace(nx, ny);
                    grid[nx][ny] = 1;
                }
            }
        }
        return false;
    }
};
```
