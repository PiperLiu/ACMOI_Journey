<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [格雷编码（格雷码/镜面找规律/背公式）](#格雷编码格雷码镜面找规律背公式)
- [306. 累加数（分析/高精度/考察逻辑清晰）](#306-累加数分析高精度考察逻辑清晰)

<!-- /code_chunk_output -->

### 格雷编码（格雷码/镜面找规律/背公式）

https://leetcode-cn.com/problems/gray-code

$n$ 位格雷码序列 是一个由 $2n$ 个整数组成的序列，其中：
- 每个整数都在范围 $[0, 2n - 1]$ 内（含 $0$ 和 $2n - 1$）
- 第一个整数是 $0$
- 一个整数在序列中出现 不超过一次
- 每对 相邻 整数的二进制表示 恰好一位不同 ，且
- 第一个 和 最后一个 整数的二进制表示 恰好一位不同
- 给你一个整数 $n$ ，返回任一有效的 $n$ 位格雷码序列 。

```
输入：n = 2
输出：[0,1,3,2]
解释：
[0,1,3,2] 的二进制表示是 [00,01,11,10] 。
- 00 和 01 有一位不同
- 01 和 11 有一位不同
- 11 和 10 有一位不同
- 10 和 00 有一位不同
[0,2,3,1] 也是一个有效的格雷码序列，其二进制表示是 [00,10,11,01] 。
- 00 和 10 有一位不同
- 10 和 11 有一位不同
- 11 和 01 有一位不同
- 01 和 00 有一位不同
```

```
输入：n = 1
输出：[0,1]
```

提示：
- $1 \le n \le 16$

参考：
- https://leetcode-cn.com/problems/gray-code/solution/ge-lei-bian-ma-by-leetcode-solution-cqi7/
- https://leetcode-cn.com/u/qian-ikong/

**方法一：对称生成**

假设我们已经获取到 $n-1$ 位的格雷码序列 $G_{n-1}$，我们只需要将 $G_{n-1}$ 对称翻转，记作 $G_{n-1}^T$ 。$G_{n-1}$ 的首元素和 $G_{n-1}^T$ 的尾元素都是相同的，反之亦然。如果我们给 $G_{n-1}^T$ 的每个元素都加上 $2^{n-1}$ ，记作 $(G_{n-1}^T)'$，则 $G_{n-1}$ 的首元素和 $(G_{n-1}^T)'$ 的尾元素只有一位不相同，反之亦然。因此 $G_{n-1}$ 和 $(G_{n-1}^T)'$ 拼接的序列 $G_n=[G_{n-1},~(G_{n-1}^T)']$ 满足 $n$ 位的格雷码的定义。初始值 $G_0 = [0]$。

人话解释：

```
n = 1  [0, 1]
n = 2  [00，01，11，10]
n = 3  [000, 001, 011, 010, 110, 111, 101, 100]
....
```

一位格雷码只有两个元素，`[1， 0]`

因为格雷码 `n` 每增加 `1` ，包含的数字会翻倍，这里我们设 `n` 位格雷码包含 `c` 个数，前一个 `n` 为 `n'` ，所以` c = 2c'`

所以这时 `n` 中的前 `c'` 个数是 `n'` 中的所有数字前面补 `0` ，相当于全部都是 `n'` 中的数字

```
n = 2  [ 00,  01,  11,  10] 
n = 3  [000, 001, 011, 010] (前四个数)
```

这时 `n` 中的后 `c'` 个数是 `n'` 中的所有数字前面补 `1` ，然后变为逆序

```
n = 2  [ 00,  01,  11,  10] 
       [100, 101, 111, 110]  补 1
       [110, 111, 101, 100] （后四个数逆序）
```

结果拼接

```
n = 3  [000, 001, 011, 010, 110, 111, 101, 100]
```

```cpp
class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> ret;
        ret.push_back(0);
        for (int i = 1; i <= n; ++ i)
        {
            int m = ret.size();
            for (int j = m - 1; j >= 0; -- j)
                ret.push_back(ret[j] | (1 << (i - 1)));  // 异或就是填补 0 位
        }
        return ret;
    }
};
```

时间复杂度：$O(2^n)$，其中 $n$ 为格雷码序列的位数。递推过程的时间复杂度为 $O(\sum_{i=1}^n 2^{i-1})=O(2^n)$。

空间复杂度：$O(1)$。注意返回值不计入空间复杂度。

**方法二：二进制数转格雷码**

如果我们有一个二进制数序列，我们也可以将它直接转换成格雷码序列。假设 $n$ 位二进制数为 $b$ ，对应的格雷码为 $g$ ，转换规则如下：

$$
g(i) = b(i+1) \oplus b(i),~~~~0 \le i \lt n
$$

其中 $\oplus$ 是按位异或运算，$g(i)$ 和 $b(i)$ 分别表示 $g$ 和 $b$ 的第 $i$ 位，且 $b(n)=0$ 。

上述转换规则的证明如下：

考虑 $n$ 位二进制数 $b_i$ 和对应的转换码 $g_i$，并且 $b_{i+1} = b_i + 1$ 也是 $n$ 位二进制数。$b_{i+1}$ 与 $b_i$ 的区别在于 $b_{i+1}$ 将 $b_i$ 二进制下末位连接的 $1$ 全部变成 $0$ ，然后将最低位的 $0$ 变成 $1$ 。

假设变化涉及到的二进制位数为 $k$ 位，则按照上述转换规则（$g(i) = b(i+1) \oplus b(i)$）， $g_{i+1}$ 与 $g_{i}$ 只有在第 $k - 1$ 位不相同，其他位都相同。因此转换得到的码相邻的数只有一位不同，而转换码第一个整数和最后一个整数分别由二进制数 $0$ 和 $2^n-1$ 转换而来，也只有一位不同。因为二进制数的取值范围为 $[0,~2^n)$，且上述转换规则为一对一映射，因此得到的转换码也是互不相同的，且取值范围也在 $[0,~2^n)$，得证。

我有两个问题：
- 如何更好地说明 $g_{i+1}$ 与 $g_{i}$ 只有在第 $k - 1$ 位不相同 ？
- 如何证明 `上述转换规则为一对一映射` ？

方法二人话解释：

不管`n`为几，当前n的格雷码中的前一半始终为`n - 1`的全部，所以这时我们可以忽略n在格雷码中的影响

这时我们将格雷码编号：

```
[000, 001, 011, 010, 110, 111, 101, 100 ...]
  0,   1,   2,   3 ,   4,   5,  6,   7,  ...
```

这里的`0 ~ 7..`. 转换为二进制后我们成为二进制码，比如我们要求解5对应的格雷码，这里`5`对应的二进制码就是`0101`（`4`的二进制）
二进制码对应的每一位就是小`b`，，格雷码每一位是`g`，这里讲解过程中在前面补`0`方便理解，这里的`\/`就是异或的运算

```
0   0   1   0   1
0   b3  b2  b1  b0
  \/  \/  \/  \/ 
  g3  g2  g1  g0
   0   1   1   1
```

所以我们由`5`（`0101`）推出对应的格雷码为`0111`

这里解释一下 `(i >> 1) ^ i，i>>1` 其实将`i`每一位向后移动一位，这时和`i`取异或，相当于和自己的后一位取余

```
b3 b2  b1  b0  (i)
0  b3  b2  b1  (i >> 1)
g3 g2  g1  g0  (结果) 
```

```cpp
class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> ret(1 << n);
        for (int i = 0; i < 1 << n; ++ i)
            ret[i] = (i >> 1) ^ i;
        return ret;
    }
};
```

时间复杂度：$O(2^n)$，其中 $n$ 为格雷码序列的位数。每个整数转换为格雷码的时间复杂度为 $O(1)$，总共有 $2^n$ 个转换。

空间复杂度：$O(1)$。注意返回值不计入空间复杂度。

### 306. 累加数（分析/高精度/考察逻辑清晰）

累加数是一个字符串，组成它的数字可以形成累加序列。

一个有效的 累加序列 必须 至少 包含 3 个数。除了最开始的两个数以外，字符串中的其他数都等于它之前两个数相加的和。

给你一个只包含数字`'0'-'9'`的字符串，编写一个算法来判断给定输入是否是 累加数 。如果是，返回 `true` ；否则，返回 `false` 。

说明：累加序列里的数 不会 以 `0` 开头，所以不会出现`1, 2, 03 或者`1, 02, 3`的情况。

示例 1：
```
输入："112358"
输出：true 
解释：累加序列为: 1, 1, 2, 3, 5, 8 。1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8
```

示例 2：
```
输入："199100199"
输出：true 
解释：累加序列为: 1, 99, 100, 199。1 + 99 = 100, 99 + 100 = 199
```

提示：
- $1 \le num.length \le 35$
- num 仅由数字（`0 - 9`）组成

```cpp
class Solution {
/**
 *  重点：当第一个数和第二个数确定了，后面的也就确定了
 *  所以枚举第一个和第二个数就行
 */
public:
    bool isAdditiveNumber(string num) {
        int n = num.size();
        for (int secondStart = 1; secondStart < n - 1; ++secondStart) {
            if (num[0] == '0' && secondStart != 1) {
                return false;  // 第一个数是 0pppp 不行
            }
            for (int secondEnd = secondStart; secondEnd < n - 1; ++secondEnd) {
                if (num[secondStart] == '0' && secondStart != secondEnd) {
                    break;  // 第二数有前导零，不行
                }
                if (valid(secondStart, secondEnd, num)) {
                    return true;
                }
            }
        }
        return false;
    }

    bool valid(int secondStart, int secondEnd, string num) {
        int n = num.size();
        int firstStart = 0, firstEnd = secondStart - 1;
        while (secondEnd <= n - 1) {
            // 下面验证第三个数（数值已定，找位置）
            string third = stringAdd(num, firstStart, firstEnd, secondStart, secondEnd);
            int thirdStart = secondEnd + 1;
            int thirdEnd = secondEnd + third.size();
            if (thirdEnd >= n || !(num.substr(thirdStart, thirdEnd - thirdStart + 1) == third)) {
                break;
            }
            if (thirdEnd == n - 1) {
                return true;
            }
            firstStart = secondStart;
            firstEnd = secondEnd;
            secondStart = thirdStart;
            secondEnd = thirdEnd;
        }
        return false;
    }

    string stringAdd(string s, int firstStart, int firstEnd, int secondStart, int secondEnd) {
        string third;
        int carry = 0, cur = 0;
        while (firstEnd >= firstStart || secondEnd >= secondStart || carry != 0) {
            cur = carry;
            if (firstEnd >= firstStart) {
                cur += s[firstEnd] - '0';
                --firstEnd;
            }
            if (secondEnd >= secondStart) {
                cur += s[secondEnd] - '0';
                --secondEnd;
            }
            carry = cur / 10;
            cur %= 10;
            third.push_back(cur + '0');
        }
        reverse(third.begin(), third.end());
        return third;
    }
};
```
