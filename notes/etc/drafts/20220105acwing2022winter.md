<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [2058. 笨拙的手指（秦九韶）](#2058-笨拙的手指秦九韶)
- [2041. 干草堆（差分与`nth_element`）](#2041-干草堆差分与nth_element)
- [2060. 奶牛选美（两个连通块）](#2060-奶牛选美两个连通块)

<!-- /code_chunk_output -->

### 2058. 笨拙的手指（秦九韶）

奶牛贝茜正在学习如何在不同进制之间转换数字。

但是她总是犯错误，因为她无法轻易的用两个前蹄握住笔。

每当贝茜将数字转换为一个新的进制并写下结果时，她总是将其中的某一位数字写错。

例如，如果她将数字 $14$ 转换为二进制数，那么正确的结果应为 $1110$，但她可能会写下 $0110$ 或 $1111$。

贝茜不会额外添加或删除数字，但是可能会由于写错数字的原因，写下包含前导 $0$ 的数字。

给定贝茜将数字 $N$ 转换为二进制数字以及三进制数字的结果，请确定 $N$ 的正确初始值（十进制表示）。

<h4>输入格式</h4>

第一行包含 $N$ 的二进制表示，其中一位是错误的。

第二行包含 $N$ 的三进制表示，其中一位是错误的。

<h4>输出格式</h4>

输出正确的 $N$ 的值。

<h4>数据范围</h4>

$0 \le N \le 10^9$，且存在唯一解。

<h4>输入样例：</h4>

```
1010
212
```

<h4>输出样例：</h4>

```
14
```

<h4>样例解释</h4>

$14$ 在二进制下的正确表示为 $1110$，在三进制下的正确表示为 $112$。

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <unordered_set>

using namespace std;

// 经验：进制转换可以用秦九韶算法
int get(string s, int b)  // 将b进制的数转化成十进制
{
    int res = 0;
    // 秦九韶算法
    for (auto c: s)
        res = res * b + c - '0';
    return res;
}

int main()
{
    string a, b;
    cin >> a >> b;

    unordered_set<int> S;

    // 先把所有二进制对应的可能枚举出来，放到集合 S
    for (auto&& c: a)  // 这里用引用，以改变 c
    {
        c ^= 1;
        S.insert(get(a, 2));
        c ^= 1;  // 恢复现场
    }

    // 再把三进制对应的可能枚举，如果和 S 有交集，输出
    for (auto&& c: b)
    {
        char t = c;
        for (int i = 0; i < 3; i ++ )
            if (i + '0' != t)
            {
                c = i + '0';
                int x = get(b, 3);
                if (S.count(x))
                {  // 取集合的交集
                    cout << x << endl;
                    return 0;
                }
            }
        c = t;  // 恢复 c
    }

    return 0;
}
```

**经验：**
- 进制转换可以用秦九韶算法

### 2041. 干草堆（差分与`nth_element`）

贝茜对她最近在农场周围造成的一切恶作剧感到抱歉，她同意帮助农夫约翰把一批新到的干草捆堆起来。

开始时，共有 $N$ 个空干草堆，编号 $1 \sim N$。

约翰给贝茜下达了 $K$ 个指令，每条指令的格式为 `A B`，这意味着贝茜要在 $A..B$ 范围内的每个干草堆的顶部添加一个新的干草捆。

例如，如果贝茜收到指令 `10 13`，则她应在干草堆 $10,11,12,13$ 中各添加一个干草捆。

在贝茜完成了所有指令后，约翰想知道 $N$ 个干草堆的中值高度——也就是说，如果干草堆按照高度从小到大排列，位于中间的干草堆的高度。

方便起见，$N$ 一定是奇数，所以中间堆是唯一的。

请帮助贝茜确定约翰问题的答案。

<h4>输入格式</h4>

第一行包含 $N$ 和 $K$。

接下来 $K$ 行，每行包含两个整数 $A,B$，用来描述一个指令。

<h4>输出格式</h4>

输出完成所有指令后，$N$ 个干草堆的中值高度。

<h4>数据范围</h4>

- $1 \le N \le 10^6$,
- $1 \le K \le 25000$,
- $1 \le A \le B \le N$

<h4>输入样例：</h4>

```
7 4
5 5
2 4
4 6
3 5
```

<h4>输出样例：</h4>

```
1
```

<h4>样例解释</h4>

贝茜完成所有指令后，各堆高度为 $0,1,2,3,3,1,0$。

将各高度从小到大排序后，得到 $0,0,1,1,2,3,3$，位于中间的是 $1$。

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1000010;

int n, m;
int b[N];

int main()
{
    scanf("%d%d", &n, &m);

    while (m -- )
    {
        int l, r;
        scanf("%d%d", &l, &r);
        b[l] ++, b[r + 1] -- ;
    }

    for (int i = 1; i <= n; i ++ ) b[i] += b[i - 1];

    // nth_element 期望是 O(n)
    nth_element(b + 1, b + n / 2 + 1, b + n + 1);

    printf("%d\n", b[n / 2 + 1]);

    return 0;
}
```
**经验：**
- `void nth_element (RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, Compare comp);` 中， `first` 和 `last` 都是随机访问迭代器， `[first, last)` 用于指定该函数的作用范围（即要处理哪些数据）； `nth` 也是随机访问迭代器，其功能是令函数查找“第 `nth` 大”的元素，并将其移动到 `nth` 指向的位置； `comp` 用于自定义排序规则。

### 2060. 奶牛选美（两个连通块）

听说最近两斑点的奶牛最受欢迎，约翰立即购进了一批两斑点牛。

不幸的是，时尚潮流往往变化很快，当前最受欢迎的牛变成了一斑点牛。

约翰希望通过给每头奶牛涂色，使得它们身上的两个斑点能够合为一个斑点，让它们能够更加时尚。

牛皮可用一个 $N \times M$ 的字符矩阵来表示，如下所示：

```
................
..XXXX....XXX...
...XXXX....XX...
.XXXX......XXX..
........XXXXX...
.........XXX....
```

其中，$X$ 表示斑点部分。

如果两个 $X$ 在垂直或水平方向上相邻（对角相邻不算在内），则它们属于同一个斑点，由此看出上图中恰好有两个斑点。

约翰牛群里<strong>所有的牛都有两个斑点</strong>。

约翰希望通过使用油漆给奶牛尽可能少的区域内涂色，将两个斑点合为一个。

在上面的例子中，他只需要给三个 $.$ 区域内涂色即可（新涂色区域用 $*$ 表示）：

```
................
..XXXX....XXX...
...XXXX*...XX...
.XXXX..**..XXX..
........XXXXX...
.........XXX....
```

请帮助约翰确定，为了使两个斑点合为一个，他需要涂色区域的最少数量。

<h4>输入格式</h4>

第一行包含两个整数 $N$ 和 $M$。

接下来 $N$ 行，每行包含一个长度为 $M$ 的由 $X$ 和 $.$ 构成的字符串，用来表示描述牛皮图案的字符矩阵。

<h4>输出格式</h4>

输出需要涂色区域的最少数量。

<h4>数据范围</h4>

$1 \le N,M \le 50$

<h4>输入样例：</h4>

```
6 16
................
..XXXX....XXX...
...XXXX....XX...
.XXXX......XXX..
........XXXXX...
.........XXX....
```

<h4>输出样例：</h4>

```
3
```

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 55;

int n, m;
char g[N][N];
vector<PII> points[2];

int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

void dfs(int x, int y, vector<PII>& ps)
{
    g[x][y] = '.';
    ps.push_back({x, y});

    for (int i = 0; i < 4; i ++ )
    {
        int a = x + dx[i], b = y + dy[i];
        if (a >= 0 && a < n && b >= 0 && b < m && g[a][b] == 'X')
            dfs(a, b, ps);
    }
}

int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; i ++ ) cin >> g[i];

    // 用 flood fill
    for (int i = 0, k = 0; i < n; i ++ )
        for (int j = 0; j < m; j ++ )
            if (g[i][j] == 'X')
                dfs(i, j, points[k ++ ]);  // 一定存在两个连通块，因此可以用 k++ 区别

    int res = 1e8;
    for (auto& a: points[0])
        for (auto& b: points[1])  // 枚举两个连通块中的点，用曼哈顿距离
            res = min(res, abs(a.x - b.x) + abs(a.y - b.y) - 1);

    cout << res << endl;
    return 0;
}
```
