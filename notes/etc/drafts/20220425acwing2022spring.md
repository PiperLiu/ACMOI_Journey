<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [3746. 牛的学术圈 II（思维题）](#3746-牛的学术圈-ii思维题)
- [4262. 空调（经典贪心+差分，将第一个序列变成第二个序列）](#4262-空调经典贪心差分将第一个序列变成第二个序列)
- [4367. 拍照2（贪心+双指针）](#4367-拍照2贪心双指针)

<!-- /code_chunk_output -->

### 3746. 牛的学术圈 II（思维题）

Bessie 正在申请计算机科学的研究生，并取得了一所久负盛名的计算机科学实验室的面试通知。

然而，为了避免冒犯任何人，Bessie 有意先确定实验室的 $N$ 名现有成员的相对资历。

没有两名实验室成员的资历相同，但确定他们的资历深浅可能并不好办。

为此，Bessie 将会对实验室的出版物进行调查。

每份出版物均包含一个作者列表，为所有 $N$ 名实验室成员的一个排列。

列表按每名实验室成员对这篇文章的贡献降序排列。

如果多名研究员的贡献相等，则按字典序排列。

由于更有资历的实验室成员负有更多的管理责任，更有资历的研究员从不会比资历较浅的研究员做出更多的贡献。

例如，在一个由资历较浅的学生 Elsie、资历较深的教授 Mildred、以及十分资深的教授 Dean 组成的实验室中，可能存在一篇论文 Elsie-Mildred-Dean，如果他们做出了不等的贡献（也就是说，Elsie 做出的贡献比 Mildred 更多，Mildred 比 Dean 更多）。

然而，也有可能存在一篇论文 Elsie-Dean-Mildred，如果 Mildred 和 Dean 做出了相等的贡献，而 Elsie 做出了更多的贡献。

给定实验室的 $K$ 份出版物，对于实验室中每对研究员，如果可能的话帮助 Bessie 判断其中谁的资历更深。

<h4>输入格式</h4>

输入的第一行包含两个整数 $K$ 和 $N$。

第二行包含 $N$ 个空格分隔的字符串，为实验室的成员的名字。每个字符串均由小写字母组成，且至多包含 $10$ 个字符。

以下 $K$ 行，每行包含 $N$ 个空格分隔的字符串，表示一份出版物的作者列表。

<h4>输出格式</h4>

输出 $N$ 行，每行 $N$ 个字符。在第 $i$ 行内，对于所有 $j≠i$，当可以确定第 $i$ 名成员比第 $j$ 名成员资历更深时字符 $j$ 为 `1`，当可以确定第 $i$ 名成员比第 $j$ 名成员资历更浅时字符 $j$ 为 `0`，当不能由给定的出版物确定时为 `?`。

第 $i$ 行的字符 $i$ 应为 `B`，因为这是 Bessie 最喜欢的字母。

<h4>数据范围</h4>

$1 \le N,K \le 100$

<h4>输入样例1：</h4>

```
1 3
dean elsie mildred
elsie mildred dean
```

<h4>输出样例1：</h4>

```
B11
0B?
0?B
```

<h4>样例1解释</h4>

在这个样例中，单独一份论文 elsie-mildred-dean 并不能提供足够的信息判断 Elsie 比 Mildred 资历更深或更浅。

然而，我们可以推断出 Dean 一定比这两名研究员资历更深，从而资历排序为 `Elsie<Mildred<Dean` 和 `Mildred<Elsie<Dean` 均是可能的。

<h4>输入样例2：</h4>

```
2 3
elsie mildred dean
elsie mildred dean
elsie dean mildred
```

<h4>输出样例2：</h4>

```
B00
1B0
11B
```

<h4>样例2解释</h4>

在这个样例中，唯一能与两篇论文相一致的资历排序为 `Elsie<Mildred<Dean`，这是因为基于第一个样例所提供的信息，第二篇论文可以帮助我们推断出 Mildred 比 Elsie 的资历更深。

```go
// 没有两名实验室成员的资历相同
package main

import ."fmt"

const N int = 110
var (
    n, m int
    g [N][N]int
    id = make(map[string]int)  // 不能只声明 map ，否则是 nil 指针
)

func main() {
    Scanf("%d %d", &m, &n)
    for i := 0; i < n; i ++ {
        var name string
        Scanf("%s", &name)
        id[name] = i
    }

    var name [N]string
    for m > 0 {
        m --
        for i := 0; i < n; i ++ {
            Scanf("%s", &name[i])
        }
        for i := 0; i < n; i ++ {
            j := i + 1  // 寻找字典序之外的
            for j < n && name[j] > name[j - 1] { j ++ }
            for j < n {  // 可确定从 j 开始一定高于 i
                a := id[name[i]]
                b := id[name[j]]
                g[a][b] = 1  // a 比 b 高一定矛盾
                j ++
            }
        }
    }

    // 输出
    for i := 0; i < n; i ++ {
        for j := 0; j < n; j ++ {
            if i == j {
                Print("B")
            } else if g[i][j] == 0 && g[j][i] == 0 {
                Print("?")
            } else if g[i][j] == 0 {
                Print(1)
            } else {
                Print(0)
            }
        }
        Println()
    }
}
```

### 4262. 空调（经典贪心+差分，将第一个序列变成第二个序列）

Farmer John 的 $N$ 头奶牛对他们牛棚的室温非常挑剔。

有些奶牛喜欢温度低一些，而有些奶牛则喜欢温度高一些。

Farmer John 的牛棚包含一排 $N$ 个牛栏，编号为 $1…N$，每个牛栏里有一头牛。 

第 $i$ 头奶牛希望她的牛栏中的温度是 $p_i$，而现在她的牛栏中的温度是 $t_i$。

为了确保每头奶牛都感到舒适，Farmer John 安装了一个新的空调系统。

该系统进行控制的方式非常有趣，他可以向系统发送命令，告诉它将一组连续的牛栏内的温度升高或降低 $1$ 个单位——例如「将牛栏 $5…8$ 的温度升高 $1$ 个单位」。

一组连续的牛栏最短可以仅包含一个牛栏。

请帮助 Farmer John 求出他需要向新的空调系统发送的命令的最小数量，使得每头奶牛的牛栏都处于其中的奶牛的理想温度。

<h4>输入格式</h4>

输入的第一行包含 $N$。

下一行包含 $N$ 个非负整数 $p_1…p_N$，用空格分隔。

最后一行包含 $N$ 个非负整数 $t_1…t_N$。

<h4>输出格式</h4>

输出一个整数，为 Farmer John 需要使用的最小指令数量。

<h4>数据范围</h4>

- $1 \le N \le 10^5$,
- $0 \le p_i,t_i \le 10000$

<h4>输入样例：</h4>

```
5
1 5 3 3 4
1 2 2 2 1
```

<h4>输出样例：</h4>

```
5
```

<h4>样例解释</h4>

一组最优的 Farmer John 可以使用的指令如下：

```
初始温度     ：1 2 2 2 1
升高牛棚 2..5：1 3 3 3 2
升高牛棚 2..5：1 4 4 4 3
升高牛棚 2..5：1 5 5 5 4
降低牛棚 3..4：1 5 4 4 4
降低牛棚 3..4：1 5 3 3 4
```

```go
// 首先做差，目标是将做差后的所有值转换为 0
// 将做差后的序列成为 A ，对 A 做差分
// 现在目标转换为了将 A 的差分序列所有值转换为 0
// 每次操作可以对 A 的差分序列修改两个数，为 -1, +1
// 因此，我们贪心地修改就好
package main

import (
    "bufio"; ."fmt"; "os"
)

var (
    N int = 100010
    n int
    a = make([]int, N)
)

func main() {
    in := bufio.NewReader(os.Stdin)
    Fscan(in, &n)
    for i := 1; i <= n; i ++ {
        Fscan(in, &a[i])
    }
    for i := 1; i <= n; i ++ {
        var b int
        Fscan(in, &b)
        a[i] -= b
    }
    
    // 转换为差分
    for i := n; i > 0; i -- {
        a[i] -= a[i - 1]
    }
    
    // 贪心下的最优值
    pos, neg := 0, 0
    for i := 1; i <= n; i ++ {
        if a[i] > 0 {
            pos += a[i]
        } else if a[i] < 0 {
            neg -= a[i];
        }
    }
    
    Println(max(pos, neg))
}

func max(x, y int) int { if x < y { return y } else { return x } }
```

### 4367. 拍照2（贪心+双指针）

农夫约翰有 $N$ 头奶牛，编号 $1 \sim N$。

约翰让它们排成一排，以便拍照。

最初，奶牛从左到右按照 $a_1,a_2,...,a_N$ 的顺序排列。

但是，约翰希望奶牛从左到右按照 $b_1,b_2,...,b_N$ 的顺序排列。

为此，他需要对队列进行一系列的调整操作。

每次操作可以选择任意一头奶牛并将其向左移动一些位置。

请问，至少需要多少次操作，才能使奶牛按照约翰满意的顺序排列。

<h4>输入格式</h4>

第一行包含整数 $N$。

第二行包含 $a_1,a_2,...,a_N$，这是一个 $1 \sim N$ 的排列。

第三行包含 $b_1,b_2,...,b_N$，这是一个 $1 \sim N$ 的排列。

<h4>输出格式</h4>

一个整数，表示所需的最少操作次数。

<h4>数据范围</h4>

$1 \le N \le 10^5$

<h4>输入样例1：</h4>

```
5
1 2 3 4 5
1 2 3 4 5
```

<h4>输出样例1：</h4>

```
0
```

<h4>样例1解释</h4>

本样例中，奶牛已经按照约翰满意的顺序排列，因此无需任何操作。

<h4>输入样例2：</h4>

```
5
5 1 3 2 4
4 5 2 1 3
```

<h4>输出样例2：</h4>

```
2
```

<h4>样例2解释</h4>

在本样例中，至少需要 $2$ 次操作，具体如下：
- 让奶牛 $4$ 向左移动 $4$ 位。
- 让奶牛 $2$ 向左移动 $2$ 位。

队列变化如下：

```
   5 1 3 2 4
-> 4 5 1 3 2
-> 4 5 2 1 3
```

```cpp
// 根据 b 序列，从前到后贪心地把 a 中的数差到前面来
// 可以用链表，当然这里数组+双指针做就很简洁
package main

import ( ."fmt"; "bufio"; "os" )

const N int = int(1e5 + 10)
var (
    n int
    a = make([]int, N)
    b = make([]int, N)
    p = make([]int, N)  // 数值 x 位于 a 的 p[x] 处
)

func main() {  // 用 bufio 时间 4791 ms 优化到 565 ms
    in := bufio.NewReader(os.Stdin)
    Fscan(in, &n)
    for i := 1; i <= n; i ++ {
        Fscan(in, &a[i])
        p[a[i]] = i
    }
    for i := 1; i <= n; i ++ {
        Fscan(in, &b[i])
    }
    
    var res int // res 0
    // 双指针
    for i, j := 1, 1; j <= n; j ++ {
        // i 指向 a ， j 指向 b
        for i <= n && a[i] == 0 { i ++ }  // 如果 i 指向的位置已经被移动到前面了
        if a[i] == b[j] {
            // 如果相等，则两个指针都后移，对比下一位
            i ++
        } else {  // 如果不相等，把 a 对应的数值移到前面来
            // 然后 j 后移，再与当前 i 比较
            a[p[b[j]]] = 0
            res ++
        }
    }
    Println(res)
}
```
