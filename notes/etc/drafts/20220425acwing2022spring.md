<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [3746. 牛的学术圈 II（思维题）](#3746-牛的学术圈-ii思维题)

<!-- /code_chunk_output -->

### 3746. 牛的学术圈 II（思维题）

Bessie 正在申请计算机科学的研究生，并取得了一所久负盛名的计算机科学实验室的面试通知。

然而，为了避免冒犯任何人，Bessie 有意先确定实验室的 $N$ 名现有成员的相对资历。

没有两名实验室成员的资历相同，但确定他们的资历深浅可能并不好办。

为此，Bessie 将会对实验室的出版物进行调查。

每份出版物均包含一个作者列表，为所有 $N$ 名实验室成员的一个排列。

列表按每名实验室成员对这篇文章的贡献降序排列。

如果多名研究员的贡献相等，则按字典序排列。

由于更有资历的实验室成员负有更多的管理责任，更有资历的研究员从不会比资历较浅的研究员做出更多的贡献。

例如，在一个由资历较浅的学生 Elsie、资历较深的教授 Mildred、以及十分资深的教授 Dean 组成的实验室中，可能存在一篇论文 Elsie-Mildred-Dean，如果他们做出了不等的贡献（也就是说，Elsie 做出的贡献比 Mildred 更多，Mildred 比 Dean 更多）。

然而，也有可能存在一篇论文 Elsie-Dean-Mildred，如果 Mildred 和 Dean 做出了相等的贡献，而 Elsie 做出了更多的贡献。

给定实验室的 $K$ 份出版物，对于实验室中每对研究员，如果可能的话帮助 Bessie 判断其中谁的资历更深。

<h4>输入格式</h4>

输入的第一行包含两个整数 $K$ 和 $N$。

第二行包含 $N$ 个空格分隔的字符串，为实验室的成员的名字。每个字符串均由小写字母组成，且至多包含 $10$ 个字符。

以下 $K$ 行，每行包含 $N$ 个空格分隔的字符串，表示一份出版物的作者列表。

<h4>输出格式</h4>

输出 $N$ 行，每行 $N$ 个字符。在第 $i$ 行内，对于所有 $j≠i$，当可以确定第 $i$ 名成员比第 $j$ 名成员资历更深时字符 $j$ 为 `1`，当可以确定第 $i$ 名成员比第 $j$ 名成员资历更浅时字符 $j$ 为 `0`，当不能由给定的出版物确定时为 `?`。

第 $i$ 行的字符 $i$ 应为 `B`，因为这是 Bessie 最喜欢的字母。

<h4>数据范围</h4>

$1 \le N,K \le 100$

<h4>输入样例1：</h4>

```
1 3
dean elsie mildred
elsie mildred dean
```

<h4>输出样例1：</h4>

```
B11
0B?
0?B
```

<h4>样例1解释</h4>

在这个样例中，单独一份论文 elsie-mildred-dean 并不能提供足够的信息判断 Elsie 比 Mildred 资历更深或更浅。

然而，我们可以推断出 Dean 一定比这两名研究员资历更深，从而资历排序为 `Elsie<Mildred<Dean` 和 `Mildred<Elsie<Dean` 均是可能的。

<h4>输入样例2：</h4>

```
2 3
elsie mildred dean
elsie mildred dean
elsie dean mildred
```

<h4>输出样例2：</h4>

```
B00
1B0
11B
```

<h4>样例2解释</h4>

在这个样例中，唯一能与两篇论文相一致的资历排序为 `Elsie<Mildred<Dean`，这是因为基于第一个样例所提供的信息，第二篇论文可以帮助我们推断出 Mildred 比 Elsie 的资历更深。

```go
// 没有两名实验室成员的资历相同
package main

import ."fmt"

const N int = 110
var (
    n, m int
    g [N][N]int
    id = make(map[string]int)  // 不能只声明 map ，否则是 nil 指针
)

func main() {
    Scanf("%d %d", &m, &n)
    for i := 0; i < n; i ++ {
        var name string
        Scanf("%s", &name)
        id[name] = i
    }

    var name [N]string
    for m > 0 {
        m --
        for i := 0; i < n; i ++ {
            Scanf("%s", &name[i])
        }
        for i := 0; i < n; i ++ {
            j := i + 1  // 寻找字典序之外的
            for j < n && name[j] > name[j - 1] { j ++ }
            for j < n {  // 可确定从 j 开始一定高于 i
                a := id[name[i]]
                b := id[name[j]]
                g[a][b] = 1  // a 比 b 高一定矛盾
                j ++
            }
        }
    }

    // 输出
    for i := 0; i < n; i ++ {
        for j := 0; j < n; j ++ {
            if i == j {
                Print("B")
            } else if g[i][j] == 0 && g[j][i] == 0 {
                Print("?")
            } else if g[i][j] == 0 {
                Print(1)
            } else {
                Print(0)
            }
        }
        Println()
    }
}
```
