<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [780. 到达终点（反向推导+为什么用取模而非加法）](#780-到达终点反向推导为什么用取模而非加法)
- [398. 随机数索引（水塘抽样/蓄水池抽样）](#398-随机数索引水塘抽样蓄水池抽样)

<!-- /code_chunk_output -->

### 780. 到达终点（反向推导+为什么用取模而非加法）

给定四个整数 sx , sy ，tx 和 ty，如果通过一系列的转换可以从起点 (sx, sy) 到达终点 (tx, ty)，则返回 true，否则返回 false。

从点 (x, y) 可以转换到 (x, x+y)  或者 (x+y, y)。

示例 1:
```
输入: sx = 1, sy = 1, tx = 3, ty = 5
输出: true
解释:
可以通过以下一系列转换从起点转换到终点：
(1, 1) -> (1, 2)
(1, 2) -> (3, 2)
(3, 2) -> (3, 5)
```

示例 2:

```
输入: sx = 1, sy = 1, tx = 2, ty = 2 
输出: false
```

示例 3:

```
输入: sx = 1, sy = 1, tx = 1, ty = 1 
输出: true
```

提示:
- $1 <= sx, sy, tx, ty <= 10^9$

我是用 dfs 写的，栈溢出了。为什么不能一点点加上模拟？因为确实来不及。应用一个取模，则可以省去重复的加法步骤，但这就需要反向计算。其实还是比较简单的。

```cpp
class Solution {
public:
    bool reachingPoints(int sx, int sy, int tx, int ty) {
        while (tx != ty && tx > sx && ty > sy)
        {
            if (tx > ty) tx = tx % ty;
            else ty = ty % tx;
        }

        // 首先不可能有 tx < sx && ty < sy 因为上面的 while 限制了 tx > sx && ty > sy
        // 其次如果 tx != sx && ty != sy 则说明不能抵达 sx, sy
        if (tx == sx && ty == sy) return true;
        else if (tx == sx) return ty > sy && (ty - sy) % sx == 0;
        else if (ty == sy) return tx > sx && (tx - sx) % sy == 0;
        return false;
    }
};
```

### 398. 随机数索引（水塘抽样/蓄水池抽样）

给定一个可能含有重复元素的整数数组，要求随机输出给定的数字的索引。 您可以假设给定的数字一定存在于数组中。

注意：
数组大小可能非常大。 使用太多额外空间的解决方案将不会通过测试。

示例:

```java
int[] nums = new int[] {1,2,3,3,3};
Solution solution = new Solution(nums);

// pick(3) 应该返回索引 2,3 或者 4。每个索引的返回概率应该相等。
solution.pick(3);

// pick(1) 应该返回 0。因为只有nums[0]等于1。
solution.pick(1);
```

参考[力扣](https://leetcode-cn.com/problems/random-pick-index/solution/sui-ji-shu-suo-yin-by-leetcode-solution-ofsq/)：

如果数组以文件形式存储（读者可假设构造函数传入的是个文件路径），且文件大小远超内存大小，我们是无法通过读文件的方式，将所有下标保存在内存中的，因此需要找到一种空间复杂度更低的算法。

我们可以设计如下算法实现 $\text{pick}$ 操作：

遍历 $\textit{nums}$ ，当我们第 $i$ 次遇到值为 $\textit{target}$ 的元素时，随机选择区间 $[0,i)$ 内的一个整数，如果其等于 $0$，则将返回值置为该元素的下标，否则返回值不变。

设 $\textit{nums}$ 中有 $k$ 个值为 $\textit{target}$ 的元素，该算法会保证这 $k$ 个元素的下标成为最终返回值的概率均为 $\dfrac{1}{k}$ ，证明如下：

$$
\begin{aligned} &P(第\ i\ 次遇到值为\ \textit{target}\ \ 的元素的下标成为最终返回值)\\ =&P(第\ i\ 次随机选择的值= 0) \times P(第\ i+1\ 次随机选择的值\ne 0) \times \cdots \times P(第\ k\ 次随机选择的值\ne 0)\\ =&\dfrac{1}{i} \times (1-\dfrac{1}{i+1}) \times \cdots \times (1-\dfrac{1}{k})\\ =&\dfrac{1}{i} \times \dfrac{i}{i+1} \times \cdots \times \dfrac{k-1}{k}\\ =&\dfrac{1}{k} \end{aligned}
$$

```cpp
class Solution {
    vector<int> &nums;
public:
    Solution(vector<int> &nums) : nums(nums) {}

    int pick(int target) {
        int ans;
        for (int i = 0, cnt = 0; i < nums.size(); ++i) {
            if (nums[i] == target) {
                ++cnt; // 第 cnt 次遇到 target
                if (rand() % cnt == 0) {
                    ans = i;
                }
            }
        }
        return ans;
    }
};
```
