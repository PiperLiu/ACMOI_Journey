<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1934. 贝茜放慢脚步（二路归并）](#1934-贝茜放慢脚步二路归并)
- [1929. 镜子田地（环图）](#1929-镜子田地环图)
- [简单题不详记](#简单题不详记)

<!-- /code_chunk_output -->

### 1934. 贝茜放慢脚步（二路归并）

奶牛贝茜正在参加冬季哞林匹克运动会的越野滑雪比赛。

她以每秒 $1$ 米的速度出发。

但是，随着时间的推移，她变得越来越疲倦，她开始放慢脚步。

每次放慢脚步，贝茜的速度都会降低：减速一次后，她以每秒 $1/2$ 米的速度移动，减速两次后，则以每秒 $1/3$ 米的速度移动，依此类推。

你将被告知何时何地贝茜会减速。

当减速信息格式为：

```
T 17
```

意味着，贝茜在某个时间点减速，本例表示比赛开始第 $17$ 秒贝茜减速。

当减速信息格式为：

```
D 10
```

意味着，贝茜在某个地点减速，本例表示在行进 $10$ 米处减速。

给定 $N$ 个减速信息，请计算贝茜滑完一千米需要多少秒。

将你的答案四舍五入到最接近的整数（ $0.5$ 向上舍入为 $1$）。

<h4>输入格式</h4>

第一行包含整数 $N$。

接下来 $N$ 行，每行描述一个减速信息，格式为 `T x` 或 `D x`。

无论哪种情况，$x$ 都是一个整数，保证所有减速都在贝茜滑完一千米前发生。

可能同时发生多次减速，那么这会使得贝茜的速度一下子变慢很多。

所有减速信息不一定按顺序给出。

<h4>输出格式</h4>

输出贝茜滑完一千米所需的总时间。

<h4>数据范围</h4>

$1 \le N \le 10000$

<h4>输入样例：</h4>

```
2
T 30
D 10
```

<h4>输出样例：</h4>

```
2970
```

<h4>样例解释</h4>

贝茜以每秒 $1$ 米的速度跑完前 $10$ 米，耗时 $10$ 秒。

然后她减速到每秒 $1/2$ 米，接下来的 $10$ 米要花 $20$ 秒。

然后她在第 $30$ 秒时，再次减速到每秒 $1/3$ 米。

滑完剩下的 $980$ 米需要 $980 \times 3=2940$ 秒。

因此，总时间是 $10+20+2940=2970$ 秒。

```cpp
/**
 * 说白了就是用双指针写二路归并
 * 下一个减速位置是 a[i] 下一个减速时间是 b[j]
 * v 是速度的倒数
 * 当前走过的距离是 s 走过的时间是 t
 * (a[i] - s) * v 和 b[j] - t 谁小，说明先到哪个减速点
 */
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

int n;
vector<int> a, b;

int main()
{
    scanf("%d", &n);
    char str[2];
    int x;
    for (int i = 0; i < n; ++ i)
    {
        scanf("%s%d", str, &x);
        if (*str == 'D') a.push_back(x);
        else b.push_back(x);
    }
    
    // 题目保证所有减速都在贝茜滑完一千米前发生，用 a.push_back(1000) 确认完成时间
    a.push_back(1000);
    
    sort(a.begin(), a.end());
    sort(b.begin(), b.end());
    
    // 双指针实现二路归并
    double t = 0, s = 0, v = 1;
    int i = 0, j = 0;
    while (i < a.size() || j < b.size())
    if (j == b.size() || i < a.size() && (a[i] - s) * v < b[j] - t)
    {
        t += (a[i] - s) * v;
        s = a[i];
        v ++ ;
        i ++ ;
    }
    else
    {
        s += (b[j] - t) / v;
        t = b[j];
        v ++ ;
        j ++ ;
    }
    
    printf("%.0lf\n", t);
}
```

### 1929. 镜子田地（环图）

农夫约翰在屋子外面放了一些旧镜子，他的奶牛们像往常一样调皮地偷走了它们！

奶牛们将镜子放置在了一个矩形田地中，该田地可被划分为 $N \times M$ 个方格区域。

在每个方格区域中，奶牛在其某对对角之间放置一个双面镜，因此，共有两种放法，一种为 `/` 放置（镜子连接方格左下角和右上角），另一种为 `\` 放置（镜子连接方格左上角和右下角）。

一天晚上，奶牛贝茜将激光发射器带到了该田地中。

她站在田地外面，沿着田地的行或列水平或垂直照射光束，使光束反射一定数量的镜子。

由于镜子都是沿对角线摆放，因此经反射镜反射的水平光束最终将垂直传播，反之亦然。

贝茜想知道从田地之外射入的水平或垂直光束最多可以在田地中被反射多少次。

给定镜子田地的布局，请帮助贝茜计算这个数字。

<h4>输入格式</h4>

第一行包含 $N$ 和 $M$。

接下来 $N$ 行，每行包含 $M$ 个 `/` 或 `\` 字符，表示田地中镜子的具体摆放方式。

<h4>输出格式</h4>

输出田地之外的水平或垂直光束能够被反射的最大次数。

如果可以无限反射，则输出 $-1$。

<h4>数据范围</h4>

$1 \le N,M \le 1000$

<h4>输入样例：</h4>

```
3 3
/\\
\\\
/\/
```

<h4>输出样例：</h4>

```
3
```

<h4>样例解释</h4>

贝茜可以从上向下沿中间列上方发射激光。

共可以反射 $3$ 次。

**分析：**

可以把一个格子想象成两个节点，而每个节点的度都是 2 。因此一定形成一条链。可以用 dfs 或者 bfs 因为搜索方向是固定的，只要七点起点是固定的。

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1010;

int n, m;
char g[N][N];
int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

int dfs(int x, int y, int d)
{
    if (x < 0 || x >= n || y < 0 || y >= m) return 0;

    if (g[x][y] == '/') d ^= 1;  // 1 -> 0, 2 -> 3, 3 -> 2, 0 -> 1
    else d ^= 3;

    return dfs(x + dx[d], y + dy[d], d) + 1;
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 0; i < n; i ++ ) scanf("%s", g[i]);

    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        res = max(res, dfs(i, 0, 1));  // 从左边进入，方向是 ->
        res = max(res, dfs(i, m - 1, 3));
    }

    for (int i = 0; i < m; i ++ )
    {
        res = max(res, dfs(0, i, 2));
        res = max(res, dfs(n - 1, i, 0));
    }

    printf("%d\n", res);
    return 0;
}
```

### 简单题不详记
- 1922. 懒惰的牛（滑动窗口deque） https://www.acwing.com/problem/content/1924/
