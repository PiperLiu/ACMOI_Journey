<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1332. 删除回文子序列（脑筋急转弯）](#1332-删除回文子序列脑筋急转弯)
- [1414. 和为 K 的最少斐波那契数字数目（贪心+精彩的证明）](#1414-和为-k-的最少斐波那契数字数目贪心精彩的证明)

<!-- /code_chunk_output -->

### 1332. 删除回文子序列（脑筋急转弯）

给你一个字符串 s，它仅由字母 'a' 和 'b' 组成。每一次删除操作都可以从 s 中删除一个回文 子序列。

返回删除给定字符串中所有字符（字符串为空）的最小删除次数。

「子序列」定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串的一个子序列。

「回文」定义：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文。

示例 1：
```
输入：s = "ababa"
输出：1
解释：字符串本身就是回文序列，只需要删除一次。
```

示例 2：
```
输入：s = "abb"
输出：2
解释："abb" -> "bb" -> "". 
先删除回文子序列 "a"，然后再删除 "bb"。
```

示例 3：
```
输入：s = "baabb"
输出：2
解释："baabb" -> "b" -> "". 
先删除回文子序列 "baab"，然后再删除 "b"。
```

提示：
- 1 <= s.length <= 1000
- s 仅包含字母 'a' 和 'b'

```cpp
class Solution {
public:
    int removePalindromeSub(string s) {
        /**
         * 思维题：只有两种 a 和 b
         * 因此至多删除两次
         * 删除一次的情况是本身就是回文
         */
        int n = s.size();
        for (int i = 0; i < n / 2; ++ i)
            if (s[i] != s[n - i - 1]) return 2;
        return 1;
    }
};
```

### 1414. 和为 K 的最少斐波那契数字数目（贪心+精彩的证明）

给你数字 k ，请你返回和为 k 的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。

斐波那契数字定义为：
- $F_1 = 1$
- $F_2 = 1$
- $F_n = F_{n-1} + F_{n-2}$ ， 其中 $n > 2$ 。

数据保证对于给定的 k ，一定能找到可行解。

示例 1：

```
输入：k = 7
输出：2 
解释：斐波那契数字为：1，1，2，3，5，8，13，……
对于 k = 7 ，我们可以得到 2 + 5 = 7 。
```

示例 2：

```
输入：k = 10
输出：2 
解释：对于 k = 10 ，我们可以得到 2 + 8 = 10 。
```

示例 3：

```
输入：k = 19
输出：3 
解释：对于 k = 19 ，我们可以得到 1 + 5 + 13 = 19 。
```

提示：
- $1 <= k <= 10^9$

```cpp
class Solution {
public:
    int findMinFibonacciNumbers(int k) {
        /**
         * 贪心：找到最接近 k 的斐波那契数列，然后减去
         */
        vector<int> p;
        p.push_back(1);
        int a = 1, b = 1;
        while (a + b <= k)
        {
            int c = a + b;
            p.push_back(c);
            a = b;
            b = c;
        }

        int res = 0;
        for (int i = p.size() - 1; i >= 0; -- i)
        {
            if (p[i] <= k) k -= p[i], ++ res;
            if (k == 0) break;
        }

        return res;
    }
};
```


如下是力扣的证明，三个结论，依次递进，很精彩。

首先，找到所有不超过 $k$ 的斐波那契数字，然后每次贪心地选取不超过 $k$ 的最大斐波那契数字，将 $k$ 减去该斐波那契数字，重复该操作直到 $k$ 变为 $0$，此时选取的斐波那契数字满足和为 $k$ 且数目最少。

为了证明上述方案选取的斐波那契数字数目最少，只需要证明存在一种选取斐波那契数字数目最少的方案，该方案选取了不超过 $k$ 的最大斐波那契数字。

**结论一：当选取斐波那契数字数目最少时，不可能选取两个相邻的斐波那契数。** 如下是证明。

假设选取了两个相邻的斐波那契数字 $F_x$ 和 $F_{x + 1}$ ，则根据斐波那契数字的定义，这两个斐波那契数字之和为后一个斐波那契数字：

$$F_{x+2} = F_{x} + F_{x+1}$$

因此可以用 $F_{x + 2}$ 代替 $F_x$ 和 $F_{x + 1}$ ，选取的斐波那契数字的总和不变，选取的斐波那契数字的数目减少 $1$ 个，比选取 $F_x$ 和 $F_{x + 1}$ 的方案更优。

**结论二：一定存在一种选取斐波那契数字数目最少的方案，使得选取的每个斐波那契数字各不相同。** 证明如下。

假设 $F_x$ 被选取了两次。当 $x \le 2$ 时，$F_x = 1$ ，可以用 $F_3 = 2$ 代替两个 $F_x$ ，此时选取的斐波那契数字的数目减少 $1$ 个。当 $x > 2$ 时，存在以下关系：

$$2 \times F_x = (F_{x - 2} + F_{x - 1}) + F_x = F_{x - 2} + (F_{x - 1} + F_x) = F_{x - 2} + F_{x + 1}$$

因此当 $x > 2$ 时，如果 $F_x$ 被选取了两次，则可以换成 $F_{x - 2}$ 和 $F_{x + 1}$ 。

**结论三：根据上述两个结论，必须选取不超过 k 的最大斐波那契数字，才能使得选取的斐波那契数字满足和为 k 且数目最少。** 证明如下。

用 $F_m$ 表示不超过 $k$ 的最大斐波那契数字。如果不选择 $F_m$，则考虑选取的斐波那契数字之和可能的最大值，记为 $N$。根据上述两个结论，选取的斐波那契数字中不存在相邻的斐波那契数字，也不存在重复的斐波那契数字，因此可以得到 $N$ 的表达式：

$$N = \begin{cases} F_{m - 1} + F_{m - 3} + \ldots + F_4 + F_2, &m~是奇数 \\ F_{m - 1} + F_{m - 3} + \ldots + F_3 + F_1, &m~是偶数 \end{cases}$$

当 $m$ 是奇数时，$N$ 的值计算如下：

$$\begin{aligned} N &= F_{m - 1} + F_{m - 3} + \ldots + F_4 + F_2 \\ &= F_{m - 1} + F_{m - 3} + \ldots + F_4 + F_2 + F_1 - F_1 \\ &= F_{m - 1} + F_{m - 3} + \ldots + F_4 + F_3 - F_1 \\ &= F_{m - 1} + F_{m - 3} + \ldots + F_5 - F_1 \\ &= \ldots \\ &= F_{m - 1} + F_{m - 2} - F_1 \\ &= F_m - 1 \\ &< F_m \end{aligned}$$

此时 $N < F_m$ ，由于 $F_m \le k$ ，因此 $N < k$ 。如果不选择 $F_m$ ，则选取的斐波那契数字之和一定小于 $k$，因此必须选择 $F_m$ 。

当 $m$ 是偶数时，$N$ 的值计算如下：

$$\begin{aligned} N &= F_{m - 1} + F_{m - 3} + \ldots + F_3 + F_1 \\ &= F_{m - 1} + F_{m - 3} + \ldots + F_3 + F_2 \\ &= F_{m - 1} + F_{m - 3} + \ldots + F_4 \\ &= \ldots \\ &= F_{m - 1} + F_{m - 2} \\ &= F_m \end{aligned}$$

此时 $N = F_m$ ，$\dfrac{m}{2}$ 个斐波那契数字之和等于 $F_m$ ，用一个 $F_m$ 替换 $\dfrac{m}{2}$ 个斐波那契数字，选取的斐波那契数字数目不变或减少（只有当 $m = 2$ 时，选取的斐波那契数字数目不变）。

综上所述，无论 $m$ 是奇数还是偶数，都需要选取 $F_m$，即不超过 $k$ 的最大斐波那契数字，才能使得选取的斐波那契数字满足和为 $k$ 且数目最少。

### 1405. 最长快乐字符串（贪心）

https://leetcode-cn.com/problems/longest-happy-string/

如果字符串中不含有任何 'aaa'，'bbb' 或 'ccc' 这样的字符串作为子串，那么该字符串就是一个「快乐字符串」。

给你三个整数 a，b ，c，请你返回 任意一个 满足下列全部条件的字符串 s：
- s 是一个尽可能长的快乐字符串。
- s 中 最多 有a 个字母 'a'、b 个字母 'b'、c 个字母 'c' 。
- s 中只含有 'a'、'b' 、'c' 三种字母。

如果不存在这样的字符串 s ，请返回一个空字符串 ""。

示例 1：

```
输入：a = 1, b = 1, c = 7
输出："ccaccbcc"
解释："ccbccacc" 也是一种正确答案。
```

示例 2：

```
输入：a = 2, b = 2, c = 1
输出："aabbc"
```

示例 3：

```
输入：a = 7, b = 1, c = 0
输出："aabaa"
解释：这是该测试用例的唯一正确答案。
```

提示：
- 0 <= a, b, c <= 100
- a + b + c > 0

```cpp
class Solution {
public:
    string longestDiverseString(int a, int b, int c) {
        string res;
        vector<pair<int, char>> arr = {
            {a, 'a'}, {b, 'b'}, {c, 'c'}
        };

        while (true)  // 找剩余最多的且合适的填上
        {
            sort(arr.begin(), arr.end(), [&](pair<int, char> t1, pair<int, char> t2) {
                return t1.first > t2.first;
            });
            bool f = false;
            for (auto& [freq, ch] : arr)  // 找合适的
            {
                if (freq <= 0) break;
                if (res.size() >= 2 && res[res.size() - 2] == ch && res[res.size() - 1] == ch)
                    continue;
                f = true;
                res.push_back(ch);
                freq -- ;
                break;
            }
            if (!f) break;
        }
        return res;
    }
};
```
