<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1726. 挤奶顺序（分类讨论+贪心）](#1726-挤奶顺序分类讨论贪心)
- [1696. 困牛排序（思维题+构造题）](#1696-困牛排序思维题构造题)
- [简单题不详记](#简单题不详记)

<!-- /code_chunk_output -->

### 1726. 挤奶顺序（分类讨论+贪心）

Farmer John 有 $N$ 头奶牛，编号为 $1…N$。

他每天都要给他的奶牛们挤奶。

奶牛的社会结构非常复杂，其结构有两个关键特性。

首先，有 $M$ 头奶牛的地位等级分明，按照地位越高越早挤奶的规则，这些奶牛的相对挤奶顺序是固定的。

此外，有 $K$ 头奶牛的具体挤奶顺序也是固定的，比如，奶牛 $4$ 必须在所有奶牛中的第二位挤奶。

幸运的是，Farmer John 总是能够以一种满足所有这些情况的顺序给他的奶牛们挤奶。

不幸的是，奶牛 $1$ 最近生病了，所以 Farmer John 想要尽早给这头奶牛挤奶，使得她可以回到牛棚休息。

请帮助 Farmer John 求出奶牛 $1$ 可以在挤奶顺序中出现的最早位置。

<h4>输入格式</h4>

第一行包含 $N，M，K$，表示 Farmer John 有 $N$ 头奶牛，其中 $M$ 头形成了社会阶层，$K$ 头需要在挤奶顺序中处于一个特定的位置。

下一行包含 $M$ 个不同的整数 $m_i$。在这一行出现的奶牛必须以与她们在这行出现的顺序相同的顺序进行挤奶。

下面 $K$ 行，每行包含两个整数 $c_i$ 和 $p_i$，表示奶牛 $c_i$ 一定要在第 $p_i$ 位进行挤奶。

输入数据保证：在这些限制之下，Farmer John 能够建立一个符合要求的挤奶顺序。

<h4>输出格式</h4>

输出奶牛 $1$ 可以在挤奶顺序中出现的最早位置。

<h4>数据范围</h4>

- $2 \le N \le 100$,
- $1 \le M,K < N$,
- $1 \le m_i,c_i,p_i \le N$

<h4>输入样例：</h4>

```
6 3 2
4 5 6
5 3
3 1
```

<h4>输出样例：</h4>

```
4
```

<h4>样例解释</h4>

在这个例子中，Farmer John 有六头奶牛，其中奶牛 $1$ 生病了。

他的挤奶顺序应该为奶牛 $4$ 在奶牛 $5$ 之前，奶牛 $5$ 在奶牛 $6$ 之前。

此外，Farmer John 必须要第一个给奶牛 $3$ 挤奶，第三个给奶牛 $5$ 挤奶。

FJ必须第一个给奶牛 $3$ 挤奶，由于奶牛 $4$ 必须要在奶牛 $5$ 之前，奶牛 $4$ 一定是第二个挤奶的，然后奶牛 $5$ 第三个。

于是，奶牛 $1$ 最早在挤奶顺序中出现的位置是第四个。

```cpp
/**
 * 分类讨论 + 贪心
 * 如果 1 出现在 c 中，直接输出
 * 如果 1 出现在 m 中，将 m 牛从前往后摆
 * 如果 1 没有要求，则将 m 牛从后往前摆
 */
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 110;

int n, m, k;
int q[N];  // q[i] 牛必须在这批牛的 i 顺位
int p[N];  // i 牛必须在 p[i] 上
bool st[N];

int main()
{
    cin >> n >> m >> k;

    bool flag = false;
    for (int i = 1; i <= m; i ++ )
    {
        cin >> q[i];
        if (q[i] == 1) flag = true;
    }

    memset(p, -1, sizeof p);
    for (int i = 0; i < k; i ++ )
    {
        int a, b;
        cin >> a >> b;
        if (a == 1)
        {
            cout << b << endl;
            return 0;
        }
        p[a] = b;
        st[b] = true;
    }

    if (flag)  // 如果 1 出现在 m 中
    {
        for (int i = 1, j = 1; i <= m; i ++ )
        {
            while (st[j]) j ++ ;  // 从前往后插空
            if (p[q[i]] != -1) j = p[q[i]];  // q[i] 牛强制被要求位置
            else
            {
                if (q[i] == 1)
                {
                    cout << j << endl;
                    return 0;
                }
                st[j] = true;
                j ++ ;
            }
        }
    }
    else  // 如果 1 没有限制
    {
        for (int i = m, j = n; i; i -- )
        {
            while (st[j]) j -- ;
            if (p[q[i]] != -1) j = p[q[i]];
            else
            {
                st[j] = true;
                j -- ;
            }
        }

        for (int i = 1; i <= n; i ++ )
            if (!st[i])
            {
                cout << i << endl;
                return 0;
            }
    }

    return 0;
}
```

### 1696. 困牛排序（思维题+构造题）

Farmer John 正在尝试将他的 $N$ 头奶牛，方便起见编号为 $1…N$，在她们前往牧草地吃早餐之前排好顺序。

当前，这些奶牛以 $p_1,p_2,p_3,…,p_N$ 的顺序排成一行，Farmer John 站在奶牛 $p_1$ 前面。

他想要重新排列这些奶牛，使得她们的顺序变为 $1,2,3,…,N$，奶牛 $1$ 在 Farmer John 旁边。

今天奶牛们有些困倦，所以任何时刻都只有直接面向 Farmer John 的奶牛会注意听 Farmer John 的指令。

每一次他可以命令这头奶牛沿着队伍向后移动 $k$ 步，$k$ 可以是范围 $1…N−1$ 中的任意数。

她经过的 $k$ 头奶牛会向前移动，腾出空间使得她能够插入到队伍中这些奶牛之后的位置。

例如，假设 $N=4$，奶牛们开始时是这样的顺序：

`FJ: 4, 3, 2, 1`

唯一注意 FJ 指令的奶牛是奶牛 $4$。

当他命令她向队伍后移动 $2$ 步之后，队伍的顺序会变成：

`FJ: 3, 2, 4, 1`

现在唯一注意 FJ 指令的奶牛是奶牛 $3$，所以第二次他可以给奶牛 $3$ 下命令，如此进行直到奶牛们排好了顺序。

Farmer John 急欲完成排序，这样他就可以回到他的农舍里享用他自己的早餐了。

请帮助他求出将奶牛们排好顺序所需要的最小操作次数。

<h4>输入格式</h4>

输入的第一行包含 $N$。

第二行包含 $N$ 个空格分隔的整数，$p_1,p_2,p_3,…,p_N$，表示奶牛们的起始顺序。

<h4>输出格式</h4>

输出一个整数，为 Farmer John 采用最佳策略可以将这 $N$ 头奶牛排好顺序所需要的操作次数。

<h4>数据范围</h4>

$1 \le N \le 100$

<h4>输入样例：</h4>

```
4
1 2 4 3
```

<h4>输出样例：</h4>

```
3
```

```cpp
/** 下标从 1 开始
 * 对于最右边的 a[i] > a[i+1]
 * 至少要操作 i 次，才能改变 a[i] 和 a[i+1] 的顺序
 * 想一个构造的方法，证明对于前 i 个数，操作 i 次就可以了
 * 方法为，对前 i 个数进行插入排序，插到后 i: 数中
 */
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

int main()
{
    int n;
    cin >> n;
    int a[n+1];
    for (int i = 1; i <= n; ++ i) cin >> a[i];
    for (int i = n-1; i >= 0; -- i)
        if (a[i] > a[i + 1])
        {
            cout << i << endl;
            return 0;
        }
}
```

### 简单题不详记

- 1715. 桶列表（差分） https://www.acwing.com/problem/content/1717/
