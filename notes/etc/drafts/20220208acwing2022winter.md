<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [1726. 挤奶顺序（分类讨论+贪心）](#1726-挤奶顺序分类讨论贪心)
- [简单题不详记](#简单题不详记)

<!-- /code_chunk_output -->

### 1726. 挤奶顺序（分类讨论+贪心）

Farmer John 有 $N$ 头奶牛，编号为 $1…N$。

他每天都要给他的奶牛们挤奶。

奶牛的社会结构非常复杂，其结构有两个关键特性。

首先，有 $M$ 头奶牛的地位等级分明，按照地位越高越早挤奶的规则，这些奶牛的相对挤奶顺序是固定的。

此外，有 $K$ 头奶牛的具体挤奶顺序也是固定的，比如，奶牛 $4$ 必须在所有奶牛中的第二位挤奶。

幸运的是，Farmer John 总是能够以一种满足所有这些情况的顺序给他的奶牛们挤奶。

不幸的是，奶牛 $1$ 最近生病了，所以 Farmer John 想要尽早给这头奶牛挤奶，使得她可以回到牛棚休息。

请帮助 Farmer John 求出奶牛 $1$ 可以在挤奶顺序中出现的最早位置。

<h4>输入格式</h4>

第一行包含 $N，M，K$，表示 Farmer John 有 $N$ 头奶牛，其中 $M$ 头形成了社会阶层，$K$ 头需要在挤奶顺序中处于一个特定的位置。

下一行包含 $M$ 个不同的整数 $m_i$。在这一行出现的奶牛必须以与她们在这行出现的顺序相同的顺序进行挤奶。

下面 $K$ 行，每行包含两个整数 $c_i$ 和 $p_i$，表示奶牛 $c_i$ 一定要在第 $p_i$ 位进行挤奶。

输入数据保证：在这些限制之下，Farmer John 能够建立一个符合要求的挤奶顺序。

<h4>输出格式</h4>

输出奶牛 $1$ 可以在挤奶顺序中出现的最早位置。

<h4>数据范围</h4>

- $2 \le N \le 100$,
- $1 \le M,K < N$,
- $1 \le m_i,c_i,p_i \le N$

<h4>输入样例：</h4>

```
6 3 2
4 5 6
5 3
3 1
```

<h4>输出样例：</h4>

```
4
```

<h4>样例解释</h4>

在这个例子中，Farmer John 有六头奶牛，其中奶牛 $1$ 生病了。

他的挤奶顺序应该为奶牛 $4$ 在奶牛 $5$ 之前，奶牛 $5$ 在奶牛 $6$ 之前。

此外，Farmer John 必须要第一个给奶牛 $3$ 挤奶，第三个给奶牛 $5$ 挤奶。

FJ必须第一个给奶牛 $3$ 挤奶，由于奶牛 $4$ 必须要在奶牛 $5$ 之前，奶牛 $4$ 一定是第二个挤奶的，然后奶牛 $5$ 第三个。

于是，奶牛 $1$ 最早在挤奶顺序中出现的位置是第四个。

```cpp
/**
 * 分类讨论 + 贪心
 * 如果 1 出现在 c 中，直接输出
 * 如果 1 出现在 m 中，将 m 牛从前往后摆
 * 如果 1 没有要求，则将 m 牛从后往前摆
 */
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 110;

int n, m, k;
int q[N];  // q[i] 牛必须在这批牛的 i 顺位
int p[N];  // i 牛必须在 p[i] 上
bool st[N];

int main()
{
    cin >> n >> m >> k;

    bool flag = false;
    for (int i = 1; i <= m; i ++ )
    {
        cin >> q[i];
        if (q[i] == 1) flag = true;
    }

    memset(p, -1, sizeof p);
    for (int i = 0; i < k; i ++ )
    {
        int a, b;
        cin >> a >> b;
        if (a == 1)
        {
            cout << b << endl;
            return 0;
        }
        p[a] = b;
        st[b] = true;
    }

    if (flag)  // 如果 1 出现在 m 中
    {
        for (int i = 1, j = 1; i <= m; i ++ )
        {
            while (st[j]) j ++ ;  // 从前往后插空
            if (p[q[i]] != -1) j = p[q[i]];  // q[i] 牛强制被要求位置
            else
            {
                if (q[i] == 1)
                {
                    cout << j << endl;
                    return 0;
                }
                st[j] = true;
                j ++ ;
            }
        }
    }
    else  // 如果 1 没有限制
    {
        for (int i = m, j = n; i; i -- )
        {
            while (st[j]) j -- ;
            if (p[q[i]] != -1) j = p[q[i]];
            else
            {
                st[j] = true;
                j -- ;
            }
        }

        for (int i = 1; i <= n; i ++ )
            if (!st[i])
            {
                cout << i << endl;
                return 0;
            }
    }

    return 0;
}
```

### 简单题不详记

- 1715. 桶列表（差分） https://www.acwing.com/problem/content/1717/
