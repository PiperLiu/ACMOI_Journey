
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [24. 机器人的运动范围](#24-机器人的运动范围)
- [25. 剪绳子](#25-剪绳子)
- [](#)

<!-- /code_chunk_output -->

### 24. 机器人的运动范围

地上有一个 $m$ 行和 $n$ 列的方格，横纵坐标范围分别是 $0 \sim m - 1$ 和 $0 \sim n - 1$。

一个机器人从坐标 $(0,0)$ 的格子开始移动，每一次只能向左，右，上，下四个方向移动一格。

但是不能进入行坐标和列坐标的数位之和大于 $k$ 的格子。

请问该机器人能够达到多少个格子？

<h4>样例1</h4>

```
输入：k=7, m=4, n=5

输出：20
```

<h4>样例2</h4>

```
输入：k=18, m=40, n=40

输出：1484

解释：当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。
      但是，它不能进入方格（35,38），因为3+5+3+8 = 19。
```

<strong>注意</strong>:

<ol>
<li><code>0<=m<=50</code></li>
<li><code>0<=n<=50</code></li>
<li><code>0<=k<=100</code></li>
</ol>

```cpp
class Solution {
public:
    int movingCount(int threshold, int rows, int cols)
    {
        if (!rows || !cols) return 0;  // 这句很重要
        
        auto check = [&](int a, int b)
        {
            int res = 0;
            while (a) res += (a % 10), a /= 10;
            while (b) res += (b % 10), b /= 10;
            return res <= threshold;
        };
        
        queue<pair<int, int>> q;
        int st[rows][cols];
        memset(st, 0, sizeof st);
        q.push({0, 0});
        st[0][0] = 1;

        int cnt = 0;

        int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

        while (q.size())
        {
            auto t = q.front();
            q.pop();
            cnt ++ ;

            for (int i = 0; i < 4; ++ i)
            {
                int a = t.first + dx[i], b = t.second + dy[i];
                if (a < 0 || a >= rows || b < 0 || b >= cols) continue;
                if (st[a][b]) continue;
                if (check(a, b)) q.push({a, b}), st[a][b] = 1;
            }
        }

        return cnt;
    }
};
```

### 25. 剪绳子

<h5>(数学)  $O(n)$</h5>

- 这道题目是数学中一个很经典的问题。
- 下面我们给出证明：

- 首先把一个正整数 $N$ 拆分成若干正整数只有有限种拆法，所以存在最大乘积。
- 假设 $N = n_1 + n_2 + ... + n_k$，并且 $n_1 \times n_2 \times ... \times n_k$ 是最大乘积。

- 显然$1$不会出现在其中；
- 如果对于某个 $i$ 有 $n_i \ge 5$，那么把 $n_i$ 拆分成 $3 + (n_i - 3)$，我们有 $3(n_i - 3) = 3n_i - 9 \gt n_i$；
- 如果 $n_i = 4$，拆成 $2 + 2$乘积不变，所以不妨假设没有4；
- 如果有三个以上的2，那么 $3 \times 3 \gt 2 \times 2 \times 2$，所以替换成3乘积更大；

综上，选用尽量多的3，直到剩下2或者4时，用2。

时间复杂度分析：当 $n$ 比较大时，$n$ 会被拆分成 $\lceil n / 3 \rceil$ 个数，我们需要计算这么多次减法和乘法，所以时间复杂度是 $O(n)$。

再从公式角度证明一下为什么要拆分成 $3$ ：

**已有条件：当这些数字越接近平均数时，乘积最大。** 不妨考虑一下问题：

$$\text{已知： } N=\sum_{i=1}^k n_i \text{ ,求 } \max(\prod_{i=1}^k n_i)$$

过程：令其乘积为 $y$, 则 

$$y_{max}=x^{\frac{N}{x}} \tag{1}$$

其中, $N$ 是常数，所以

$$
y_{max} \propto x^{\frac{1}{x}} \ 
= e^{\frac{\ln x}{x}}
 \tag{2}$$,

该函数单增，$g(x) = \frac{\ln x}{x}$  在 $e$ 处取得极大值也是最大值。

由于 $y(2) < y(3)$，因此 $y_{max}$ 时，$x = 3$

考虑到 $2\times 2 \times 3 > 3\times 3\times 1$， 所以在编码时还要注意在因子中不能有1
另外不包含4， 最大不超过 5， $3\times 3 > 2\times 2 \times 2$

```cpp
class Solution {
public:
    int maxProductAfterCutting(int length) {
        if (length <= 3) return 1 * (length - 1);  // 因为 m >= 2
        int res = 1;
        if (length % 3 == 1) res = 4, length -= 4;
        else if (length % 3 == 2) res = 2, length -= 2;
        while (length) res *= 3, length -= 3;
        return res;
    }
};
```

### 