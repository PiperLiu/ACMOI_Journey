
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [24. 机器人的运动范围](#24-机器人的运动范围)
- [25. 剪绳子（经典数学）](#25-剪绳子经典数学)
- [26. 二进制中1的个数（无符号整型高位自动补0）](#26-二进制中1的个数无符号整型高位自动补0)
- [27. 数值的整数次方（快速幂）](#27-数值的整数次方快速幂)
- [](#)

<!-- /code_chunk_output -->

### 24. 机器人的运动范围

地上有一个 $m$ 行和 $n$ 列的方格，横纵坐标范围分别是 $0 \sim m - 1$ 和 $0 \sim n - 1$。

一个机器人从坐标 $(0,0)$ 的格子开始移动，每一次只能向左，右，上，下四个方向移动一格。

但是不能进入行坐标和列坐标的数位之和大于 $k$ 的格子。

请问该机器人能够达到多少个格子？

<h4>样例1</h4>

```
输入：k=7, m=4, n=5

输出：20
```

<h4>样例2</h4>

```
输入：k=18, m=40, n=40

输出：1484

解释：当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。
      但是，它不能进入方格（35,38），因为3+5+3+8 = 19。
```

<strong>注意</strong>:

<ol>
<li><code>0<=m<=50</code></li>
<li><code>0<=n<=50</code></li>
<li><code>0<=k<=100</code></li>
</ol>

```cpp
class Solution {
public:
    int movingCount(int threshold, int rows, int cols)
    {
        if (!rows || !cols) return 0;  // 这句很重要
        
        auto check = [&](int a, int b)
        {
            int res = 0;
            while (a) res += (a % 10), a /= 10;
            while (b) res += (b % 10), b /= 10;
            return res <= threshold;
        };
        
        queue<pair<int, int>> q;
        int st[rows][cols];
        memset(st, 0, sizeof st);
        q.push({0, 0});
        st[0][0] = 1;

        int cnt = 0;

        int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

        while (q.size())
        {
            auto t = q.front();
            q.pop();
            cnt ++ ;

            for (int i = 0; i < 4; ++ i)
            {
                int a = t.first + dx[i], b = t.second + dy[i];
                if (a < 0 || a >= rows || b < 0 || b >= cols) continue;
                if (st[a][b]) continue;
                if (check(a, b)) q.push({a, b}), st[a][b] = 1;
            }
        }

        return cnt;
    }
};
```

### 25. 剪绳子（经典数学）

<h5>(数学)  $O(n)$</h5>

- 这道题目是数学中一个很经典的问题。
- 下面我们给出证明：

- 首先把一个正整数 $N$ 拆分成若干正整数只有有限种拆法，所以存在最大乘积。
- 假设 $N = n_1 + n_2 + ... + n_k$，并且 $n_1 \times n_2 \times ... \times n_k$ 是最大乘积。

- 显然$1$不会出现在其中；
- 如果对于某个 $i$ 有 $n_i \ge 5$，那么把 $n_i$ 拆分成 $3 + (n_i - 3)$，我们有 $3(n_i - 3) = 3n_i - 9 \gt n_i$；
- 如果 $n_i = 4$，拆成 $2 + 2$乘积不变，所以不妨假设没有4；
- 如果有三个以上的2，那么 $3 \times 3 \gt 2 \times 2 \times 2$，所以替换成3乘积更大；

综上，选用尽量多的3，直到剩下2或者4时，用2。

时间复杂度分析：当 $n$ 比较大时，$n$ 会被拆分成 $\lceil n / 3 \rceil$ 个数，我们需要计算这么多次减法和乘法，所以时间复杂度是 $O(n)$。

再从公式角度证明一下为什么要拆分成 $3$ ：

**已有条件：当这些数字越接近平均数时，乘积最大。** 不妨考虑一下问题：

$$\text{已知： } N=\sum_{i=1}^k n_i \text{ ,求 } \max(\prod_{i=1}^k n_i)$$

过程：令其乘积为 $y$, 则 

$$y_{max}=x^{\frac{N}{x}} \tag{1}$$

其中, $N$ 是常数，所以

$$
y_{max} \propto x^{\frac{1}{x}} \ 
= e^{\frac{\ln x}{x}}
 \tag{2}$$,

该函数单增，$g(x) = \frac{\ln x}{x}$  在 $e$ 处取得极大值也是最大值。

由于 $y(2) < y(3)$，因此 $y_{max}$ 时，$x = 3$

考虑到 $2\times 2 \times 3 > 3\times 3\times 1$， 所以在编码时还要注意在因子中不能有1
另外不包含4， 最大不超过 5， $3\times 3 > 2\times 2 \times 2$

```cpp
class Solution {
public:
    int maxProductAfterCutting(int length) {
        if (length <= 3) return 1 * (length - 1);  // 因为 m >= 2
        int res = 1;
        if (length % 3 == 1) res = 4, length -= 4;
        else if (length % 3 == 2) res = 2, length -= 2;
        while (length) res *= 3, length -= 3;
        return res;
    }
};
```

### 26. 二进制中1的个数（无符号整型高位自动补0）

输入一个 32 位整数，输出该数二进制表示中 1 的个数。

注意：
- 负数在计算机中用其绝对值的补码来表示。

样例1
```
输入：9
输出：2
解释：9的二进制表示是1001，一共有2个1。
```

样例2
```
输入：-2
输出：31
解释：-2在计算机里会被表示成11111111111111111111111111111110，
      一共有31个1。
```

```cpp
// 这里有个难点是如何处理负数。
// 在C++中如果我们右移一个负整数，系统会自动在最高位补 1 ，
// 这样会导致 n 永远不为 0 ，就死循环了。
// 解决办法是把 n 强制转化成无符号整型，
// 这样 n 的二进制表示不会发生改变，
// 但在右移时系统会自动在最高位补 0

class Solution {
public:
    int NumberOf1(int n) {
        int res = 0;
        unsigned int un = n;
        while (un) res += un & 1, un >>= 1;
        return res;
    }
};
```

### 27. 数值的整数次方（快速幂）

实现函数`double Power(double base, int exponent)`，求`base`的 `exponent` 次方。

不得使用库函数，同时不需要考虑大数问题。

只要输出结果与答案的绝对误差不超过 $10^{−2}$ 即视为正确。

注意：
- 不会出现底数和指数同为0的情况
- 当底数为0时，指数一定为正

样例1
```
输入：10 ，2

输出：100
```

样例2
```
输入：10 ，-2  

输出：0.01
```

```cpp
class Solution {
public:
    double Power(double base, int exponent) {
        bool isNeg = exponent < 0;
        double res = 1;
        
        // 将 n 转为 long long
        // 防止 abs(-2147483648) 变为 2147483647 溢出
        for (long long k = abs((long long) exponent); k; k >>= 1)
        {
            if (k & 1) res *= base;
            base *= base;
        }

        if (isNeg) res = 1 / res;  // 可以处理 1 / 0.0
        return res;
    }
};
```

### 