
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [37. 树的子结构（递归）](#37-树的子结构递归)
- [38. 二叉树的镜像（递归）](#38-二叉树的镜像递归)
- [39. 对称的二叉树（递归/非递归用栈实现中序遍历/逆中序遍历）](#39-对称的二叉树递归非递归用栈实现中序遍历逆中序遍历)

<!-- /code_chunk_output -->

### 37. 树的子结构（递归）

输入两棵二叉树 $A，B$，判断 $B$ 是不是 $A$ 的子结构。

我们规定空树不是任何树的子结构。

<h4>样例</h4>

树 $A$：

```
     8
    / \
   8   7
  / \
 9   2
    / \
   4   7
```

树 $B$：

```
   8
  / \
 9   2
```

返回 <strong>true</strong>，因为 $B$ 是 $A$ 的子结构。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool hasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) {
        if (!pRoot1 || !pRoot2) return false;
        if (isSame(pRoot1, pRoot2)) return true;
        return hasSubtree(pRoot1->left, pRoot2) || hasSubtree(pRoot1->right, pRoot2);
    }
    
    bool isSame(TreeNode* pRoot1, TreeNode* pRoot2)
    {
        if (!pRoot2) return true;  // 子结构可以短一些
        if (!pRoot1 || pRoot1->val != pRoot2->val) return false;
        return isSame(pRoot1->left, pRoot2->left) && isSame(pRoot1->right, pRoot2->right);
    }
};
```

### 38. 二叉树的镜像（递归）

输入一个二叉树，将它变换为它的镜像。

<h4>样例</h4>

```
输入树：
      8
     / \
    6  10
   / \ / \
  5  7 9 11

 [8,6,10,5,7,9,11,null,null,null,null,null,null,null,null] 
输出树：
      8
     / \
    10  6
   / \ / \
  11 9 7  5

 [8,10,6,11,9,7,5,null,null,null,null,null,null,null,null]
```

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    void mirror(TreeNode* root) {
        if (!root) return ;
        swap(root->left, root->right);
        mirror(root->left);
        mirror(root->right);
    }
};
```

### 39. 对称的二叉树（递归/非递归用栈实现中序遍历/逆中序遍历）

请实现一个函数，用来判断一棵二叉树是不是对称的。

如果一棵二叉树和它的镜像一样，那么它是对称的。

样例
```
如下图所示二叉树[1,2,2,3,4,4,3,null,null,null,null,null,null,null,null]为对称二叉树：
    1
   / \
  2   2
 / \ / \
3  4 4  3

如下图所示二叉树[1,2,2,null,4,4,3,null,null,null,null,null,null]不是对称二叉树：
    1
   / \
  2   2
   \ / \
   4 4  3
```

方法一：递归，第一棵子树的左子树和第二棵子树的右子树互为镜像，且第一棵子树的右子树和第二棵子树的左子树互为镜像。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        return !root || dfs(root->left, root->right);
    }
    
    bool dfs(TreeNode* l, TreeNode* r)
    {
        if (!l || !r) return !l && !r;  // 不存在的话必须同时不存在
        return l->val == r->val && dfs(l->right, r->left) && dfs(l->left, r->right);
    }
};
```

方法二：非递归，左子树中序遍历，右子树逆中序遍历（反中序遍历）。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (!root) return true;

        stack<TreeNode*> left, right;  // 用于非递归地中序遍历
        TreeNode *lc = root->left, *rc = root->right;
        while (lc || rc || left.size())
        {
            while (lc && rc)
            {
                left.push(lc), right.push(rc);
                lc = lc->left, rc = rc->right;
            }
            if (lc || rc) return false;  // 不对称
            lc = left.top(), rc = right.top();
            left.pop(), right.pop();
            if (lc->val != rc->val) return false;
            lc = lc->right, rc = rc->left;  // 出栈后选取 右/左 子节点以实现中序/反中序遍历
        }
        return true;
    }
};
```
