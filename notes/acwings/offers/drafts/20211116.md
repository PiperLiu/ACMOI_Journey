
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [13. 找出数组中重复的数字（思维严谨/节省空间）](#13-找出数组中重复的数字思维严谨节省空间)
- [14. 不修改数组找出重复的数字（O(1)空间：抽屉原理/二分）](#14-不修改数组找出重复的数字o1空间抽屉原理二分)
- [](#)

<!-- /code_chunk_output -->

### 13. 找出数组中重复的数字（思维严谨/节省空间）

给定一个长度为 `n` 的整数数组 `nums`，数组中所有的数字都在 `0∼n−1` 的范围内。

数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。

请找出数组中任意一个重复的数字。

注意：如果某些数字不在 `0∼n−1` 的范围内，或数组中不包含重复数字，则返回 `-1`；

样例
```
给定 nums = [2, 3, 5, 4, 3, 2, 6, 7]。

返回 2 或 3。
```

不节省空间版：

```cpp
class Solution {
public:
    int duplicateInArray(vector<int>& nums) {
        int n = nums.size();
        unordered_map<int, int> hash;
        int flag = -1;
        for (auto&& i: nums)
        {
            if (i < 0 || i > n - 1) return -1;
            if (hash.count(i)) flag = i;  // 不能直接 return ，因为还没有检查完全部数字
            else hash[i] = 1;
        }
        if (flag != -1) return flag;
        return -1;
    }
};
```

节省空间版：

首先遍历一遍数组，如果存在某个数不在`0`到`n-1`的范围内，则返回`-1`。

下面的算法的主要思想是把每个数放到对应的位置上，即让 `nums[i] = i`。

从前往后遍历数组中的所有数，假设当前遍历到的数是 `nums[i]=x` ，那么：
- 如果`x != i && nums[x] == x`，则说明 `x` 出现了多次，直接返回 `x` 即可；
- 如果`nums[x] != x`，那我们就把 `x` 交换到正确的位置上，即 `swap(nums[x], nums[i])`，交换完之后如果`nums[i] != i`，则重复进行该操作。由于每次交换都会将一个数放在正确的位置上，所以`swap`操作最多会进行 `n` 次，不会发生死循环。

循环结束后，如果没有找到任何重复的数，则返回`-1`。

```cpp
class Solution {
public:
    int duplicateInArray(vector<int>& nums) {
        int n = nums.size();
        for (auto x : nums)
            if (x < 0 || x >= n)
                return -1;
        for (int i = 0; i < n; i ++ ) {
            while (nums[nums[i]] != nums[i]) swap(nums[i], nums[nums[i]]);
            // 因为长度为 n
            // 因此 nums[i] != i 说明一定有重复的
            if (nums[i] != i) return nums[i];
        }
        return -1;
    }
};
```

### 14. 不修改数组找出重复的数字（O(1)空间：抽屉原理/二分）

给定一个长度为 `n+1` 的数组`nums`，数组中所有的数均在 `1∼n` 的范围内，其中 `n≥1`。

请找出数组中任意一个重复的数，但不能修改输入的数组。

样例
```
给定 nums = [2, 3, 5, 4, 3, 2, 6, 7]。

返回 2 或 3。
```

思考题：如果只能使用 $O(1)$ 的额外空间，该怎么做呢？

分析：

> 抽屉原理：n+1 个苹果放在 n 个抽屉里，那么至少有一个抽屉中会放两个苹果。

抽屉原理用在这个题目中就是，一共有 `n+1` 个数，每个数的取值范围是 `1` 到 `n` ，所以至少会有一个数出现两次。

然后我们采用分治的思想，将每个数的取值的区间`[1, n]`划分成`[1, n/2]`和`[n/2+1, n]`两个子区间，然后分别统计两个区间中数的个数。

注意这里的区间是指 **数的取值范围** ，而不是 **数组下标** 。

划分之后，左右两个区间里一定至少存在一个区间，区间中数的个数大于区间长度。

这个可以用 **反证法** 来说明：如果两个区间中数的个数都小于等于区间长度，那么整个区间中数的个数就小于等于`n`，和有 `n+1` 个数矛盾。

因此我们可以把问题划归到左右两个子区间中的一个，而且由于区间中数的个数大于区间长度，根据抽屉原理，在这个子区间中一定存在某个数出现了两次。

以此类推，每次我们可以把区间长度缩小一半，直到区间长度为1时，我们就找到了答案。

复杂度分析
- 时间复杂度：每次会将区间长度缩小一半，一共会缩小 $O(logn)$ 次。每次统计两个子区间中的数时需要遍历整个数组，时间复杂度是 $O(n)$ 。所以总时间复杂度是 $O(nlogn)$ 。
- 空间复杂度：代码中没有用到额外的数组，所以额外的空间复杂度是 $O(1)$ 。

```cpp
class Solution {
public:
    int duplicateInArray(vector<int>& nums) {
        int n = nums.size() - 1;
        int l = 1, r = n;
        while (l < r)
        {
            int mid = l + r >> 1;
            // 分为 [l, mid] 和 [mid + 1, r] 两个范围
            // 看看前者有多少个数字
            int s = 0;
            for (auto&& x: nums) if (x >= l && x <= mid) s ++ ;
            if (s > mid - l + 1) r = mid;  // 如果前者区间中有重复数字
            else l = mid + 1;
        }
        return l;
    }
};
```

### 