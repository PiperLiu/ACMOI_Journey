
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [13. 找出数组中重复的数字（思维严谨/节省空间）](#13-找出数组中重复的数字思维严谨节省空间)
- [14. 不修改数组找出重复的数字（O(1)空间：抽屉原理/二分）](#14-不修改数组找出重复的数字o1空间抽屉原理二分)
- [15. 二维数组中的查找](#15-二维数组中的查找)
- [16. 替换空格（在原字符串上resize/双指针）](#16-替换空格在原字符串上resize双指针)
- [18. 重建二叉树](#18-重建二叉树)

<!-- /code_chunk_output -->

### 13. 找出数组中重复的数字（思维严谨/节省空间）

给定一个长度为 `n` 的整数数组 `nums`，数组中所有的数字都在 `0∼n−1` 的范围内。

数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。

请找出数组中任意一个重复的数字。

注意：如果某些数字不在 `0∼n−1` 的范围内，或数组中不包含重复数字，则返回 `-1`；

样例
```
给定 nums = [2, 3, 5, 4, 3, 2, 6, 7]。

返回 2 或 3。
```

不节省空间版：

```cpp
class Solution {
public:
    int duplicateInArray(vector<int>& nums) {
        int n = nums.size();
        unordered_map<int, int> hash;
        int flag = -1;
        for (auto&& i: nums)
        {
            if (i < 0 || i > n - 1) return -1;
            if (hash.count(i)) flag = i;  // 不能直接 return ，因为还没有检查完全部数字
            else hash[i] = 1;
        }
        if (flag != -1) return flag;
        return -1;
    }
};
```

节省空间版：

首先遍历一遍数组，如果存在某个数不在`0`到`n-1`的范围内，则返回`-1`。

下面的算法的主要思想是把每个数放到对应的位置上，即让 `nums[i] = i`。

从前往后遍历数组中的所有数，假设当前遍历到的数是 `nums[i]=x` ，那么：
- 如果`x != i && nums[x] == x`，则说明 `x` 出现了多次，直接返回 `x` 即可；
- 如果`nums[x] != x`，那我们就把 `x` 交换到正确的位置上，即 `swap(nums[x], nums[i])`，交换完之后如果`nums[i] != i`，则重复进行该操作。由于每次交换都会将一个数放在正确的位置上，所以`swap`操作最多会进行 `n` 次，不会发生死循环。

循环结束后，如果没有找到任何重复的数，则返回`-1`。

```cpp
class Solution {
public:
    int duplicateInArray(vector<int>& nums) {
        int n = nums.size();
        for (auto x : nums)
            if (x < 0 || x >= n)
                return -1;
        for (int i = 0; i < n; i ++ ) {
            while (nums[nums[i]] != nums[i]) swap(nums[i], nums[nums[i]]);
            // 因为长度为 n
            // 因此 nums[i] != i 说明一定有重复的
            if (nums[i] != i) return nums[i];
        }
        return -1;
    }
};
```

### 14. 不修改数组找出重复的数字（O(1)空间：抽屉原理/二分）

给定一个长度为 `n+1` 的数组`nums`，数组中所有的数均在 `1∼n` 的范围内，其中 `n≥1`。

请找出数组中任意一个重复的数，但不能修改输入的数组。

样例
```
给定 nums = [2, 3, 5, 4, 3, 2, 6, 7]。

返回 2 或 3。
```

思考题：如果只能使用 $O(1)$ 的额外空间，该怎么做呢？

分析：

> 抽屉原理：n+1 个苹果放在 n 个抽屉里，那么至少有一个抽屉中会放两个苹果。

抽屉原理用在这个题目中就是，一共有 `n+1` 个数，每个数的取值范围是 `1` 到 `n` ，所以至少会有一个数出现两次。

然后我们采用分治的思想，将每个数的取值的区间`[1, n]`划分成`[1, n/2]`和`[n/2+1, n]`两个子区间，然后分别统计两个区间中数的个数。

注意这里的区间是指 **数的取值范围** ，而不是 **数组下标** 。

划分之后，左右两个区间里一定至少存在一个区间，区间中数的个数大于区间长度。

这个可以用 **反证法** 来说明：如果两个区间中数的个数都小于等于区间长度，那么整个区间中数的个数就小于等于`n`，和有 `n+1` 个数矛盾。

因此我们可以把问题划归到左右两个子区间中的一个，而且由于区间中数的个数大于区间长度，根据抽屉原理，在这个子区间中一定存在某个数出现了两次。

以此类推，每次我们可以把区间长度缩小一半，直到区间长度为1时，我们就找到了答案。

复杂度分析
- 时间复杂度：每次会将区间长度缩小一半，一共会缩小 $O(logn)$ 次。每次统计两个子区间中的数时需要遍历整个数组，时间复杂度是 $O(n)$ 。所以总时间复杂度是 $O(nlogn)$ 。
- 空间复杂度：代码中没有用到额外的数组，所以额外的空间复杂度是 $O(1)$ 。

```cpp
class Solution {
public:
    int duplicateInArray(vector<int>& nums) {
        int n = nums.size() - 1;
        int l = 1, r = n;
        while (l < r)
        {
            int mid = l + r >> 1;
            // 分为 [l, mid] 和 [mid + 1, r] 两个范围
            // 看看前者有多少个数字
            int s = 0;
            for (auto&& x: nums) if (x >= l && x <= mid) s ++ ;
            if (s > mid - l + 1) r = mid;  // 如果前者区间中有重复数字
            else l = mid + 1;
        }
        return l;
    }
};
```

### 15. 二维数组中的查找

在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。

请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

样例
```
输入数组：

[
  [1,2,8,9]，
  [2,4,9,12]，
  [4,7,10,13]，
  [6,8,11,15]
]

如果输入查找数值为7，则返回true，

如果输入查找数值为5，则返回false。
```

核心在于发现每个子矩阵右上角的数的性质：

如下图所示，`x`左边的数都小于等于`x`，`x`下边的数都大于等于`x`。

```
a a a a x
        b
        b
        b
        b
```

因此我们可以从整个矩阵的右上角开始枚举，假设当前枚举的数是 x：
- 如果 `x` 等于`target`，则说明我们找到了目标值，返回true；
- 如果 `x` 小于`target`，则 `x` 左边的数一定都小于`target`，我们可以直接排除当前一整行的数；
- 如果 `x` 大于`target`，则 `x` 下边的数一定都大于`target`，我们可以直接排序当前一整列的数；

排除一整行就是让枚举的点的横坐标加一，排除一整列就是让纵坐标减一。

当我们排除完整个矩阵后仍没有找到目标值时，就说明目标值不存在，返回`false`。

时间复杂度分析
- 每一步会排除一行或者一列，矩阵一共有 $n$ 行，$m$ 列，所以最多会进行 $n+m$ 步。所以时间复杂度是 $O(n+m)$。

```cpp
class Solution {
public:
    bool searchArray(vector<vector<int>> array, int target) {
        if (array.empty() || array[0].empty()) return false;  // 注意这题没有给数据范围
        int n = array.size(), m = array[0].size();
        int i = 0, j = m - 1;
        while (i < n && j >= 0)
        {
            if (array[i][j] > target) -- j;
            else if (array[i][j] < target) ++ i;
            else return true;
        }
        return false;
    }
};
```

### 16. 替换空格（在原字符串上resize/双指针）

请实现一个函数，把字符串中的每个空格替换成`%20`。

你可以假定输入字符串的长度最大是 `1000`。

注意输出字符串的长度可能大于 `1000`。

样例
```
输入："We are happy."

输出："We%20are%20happy."
```

**方法一：逐一替换**

```cpp
class Solution {
public:
    string replaceSpaces(string &str) {
        string res;
        for (auto&& c: str)
        {
            if (c == ' ')
            res += "%20";
            else res += c;
        }
        return res;
    }
};
```

**方法二：双指针**

在部分编程语言中，我们可以动态地将原数组长度扩大，此时我们就可以使用双指针算法，来降低空间的使用：

- 首先遍历一遍原数组，求出最终答案的长度`length`；
- 将原数组`resize`成`length`大小；
- 使用两个指针，指针`i`指向原字符串的末尾，指针j指向`length`的位置；
- 两个指针分别从后往前遍历，如果`str[i] == ' '`，则指针j的位置上依次填充`'0'`, `'2'`, `'%'`，这样倒着看就是"`%20`"；如果`str[i] != ' '`，则指针`j`的位置上填充该字符即可。

由于`i`之前的字符串，在变换之后，长度一定不小于原字符串，所以遍历过程中一定有`i <= j`，这样可以保证`str[j]`不会覆盖还未遍历过的`str[i]`，从而答案是正确的。

时间复杂度分析
- 原字符串只会被遍历常数次，所以总时间复杂度是 $O(n)$。

```cpp
class Solution {
public:
    string replaceSpaces(string &str) {
        int len = 0;
        for (auto&& c: str)
        {
            if (c == ' ') len += 3;
            else len += 1;
        }
        int i = str.size() - 1, j = len - 1;
        str.resize(len);
        while (i >= 0)
        {
            if (str[i] == ' ')
            {
                str[j --] = '0';
                str[j --] = '2';
                str[j --] = '%';
            }
            else str[j --] = str[i];
            -- i;
        }
        return str;
    }
};
```

这个方法节省了空间，但是并没有带来更快的速度。

### 18. 重建二叉树

输入一棵二叉树前序遍历和中序遍历的结果，请重建该二叉树。

注意:
- 二叉树中每个节点的值都互不相同；
- 输入的前序遍历和中序遍历一定合法；

样例
```
给定：
前序遍历是：[3, 9, 20, 15, 7]
中序遍历是：[9, 3, 15, 20, 7]

返回：[3, 9, 20, null, null, 15, 7, null, null, null, null]
返回的二叉树如下所示：
    3
   / \
  9  20
    /  \
   15   7
```

