
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [计算abc](#计算abc)
- [凑平方](#凑平方)
- [最大化最短路](#最大化最短路)

<!-- /code_chunk_output -->

没参加。

### 计算abc

有三个<strong>正整数</strong> $a,b,c$，我们不知道每个数的具体值，但我们知道 $a \le b \le c$。

现在，以<strong>随机顺序</strong>给出 $a+b,a+c,b+c,a+b+c$ 的值，请你求出 $a,b,c$ 的值。

<h4>输入格式</h4>

共一行，包含四个整数 $x_1,x_2,x_3,x_4$，表示以<strong>随机顺序</strong>给出的 $a+b,a+c,b+c,a+b+c$ 的值。

<h4>输出格式</h4>

共一行，三个空格隔开的整数 $a,b,c$。

<h4>数据范围</h4>

前三个测试点满足 $2 \le x_i \le 1000$。<br />
所有测试点满足 $2 \le x_i \le 10^9$。<br />
保证一定有解。

<h4>输入样例1：</h4>

<pre><code>
3 6 5 4
</code></pre>

<h4>输出样例1：</h4>

<pre><code>
1 2 3
</code></pre>

<h4>输入样例2：</h4>

<pre><code>
40 40 40 60
</code></pre>

<h4>输出样例2：</h4>

<pre><code>
20 20 20
</code></pre>

<h4>输入样例3：</h4>

<pre><code>
201 101 101 200
</code></pre>

<h4>输出样例3：</h4>

<pre><code>
1 100 100
</code></pre>

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 4;
int a[N];

int main()
{
    int n = 4;
    for (int i = 0; i < n; i ++ ) scanf("%d", &a[i]);
    
    sort(a, a + n);
    
    for (int i = 2; i >= 0; i -- ) printf("%d ", a[3] - a[i]);
}
```

### 凑平方

给定一个不含前导 $0$ 的正整数 $n$。

你可以对 $n$ 进行删位操作。

每次操作，可以将 $n$ 的任意一位数字删去，但是需要保证每次操作完成后的数字仍然是不含前导 $0$ 的正整数。

如果想要使得 $n$ 可以成为某个正整数的平方，那么最少需要对 $n$ 进行多少次操作？

<h4>输入格式</h4>

第一行包含整数 $T$，表示共有 $T$ 组测试数据。

每组数据占一行，包含一个整数 $n$。

<h4>输出格式</h4>

每组数据输出一行结果，表示最少需要的操作次数，如果不可能使 $n$ 变为某个正整数的平方，则输出 $-1$。

<h4>数据范围</h4>

前三个测试点满足 $1 \le n \le 10000$。<br />
所有测试点满足 $1 \le T \le 10$，$1 \le n \le 2 \times 10^9$。

<h4>输入样例1：</h4>

<pre><code>
1
8314
</code></pre>

<h4>输出样例1：</h4>

<pre><code>
2
</code></pre>

<h4>输入样例2：</h4>

<pre><code>
1
625
</code></pre>

<h4>输出样例2：</h4>

<pre><code>
0
</code></pre>

<h4>输入样例3：</h4>

<pre><code>
1
333
</code></pre>

<h4>输出样例3：</h4>

<pre><code>
-1
</code></pre>

```cpp

```

### 最大化最短路

给定一个 $n$ 个点 $m$ 条边的<strong>无向</strong>连通图。

图中所有点的编号为 $1 \sim n$。

<p>图中不含重边和自环。</p>

指定图中的 $k$ 个点为特殊点。

<p>现在，你<strong>必须</strong>选择两个特殊点，并在这两个点之间增加一条边。</p>

<p>所选两点之间允许原本就存在边。</p>

我们希望，在增边操作完成以后，点 $1$ 到点 $n$ 的最短距离尽可能<strong>大</strong>。

<p>输出这个最短距离的最大可能值。</p>

注意，图中所有边（包括新增边）的边长均为 $1$。

<h4>输入格式</h4>

第一行包含三个整数 $n,m,k$。

第二行包含 $k$ 个整数 $a_1,a_2,...,a_k$，表示 $k$ 个特殊点的编号，$a_i$ 之间两两不同。

接下来 $m$ 行，每行包含两个整数 $x,y$，表示点 $x$ 和点 $y$ 之间存在一条边。

<h4>输出格式</h4>

<p>一个整数，表示最短距离的最大可能值。</p>

<h4>数据范围</h4>

前六个测试点满足 $2 \le n \le 100$。

所有测试点满足 $2 \le n \le 2 \times 10^5$，$n-1 \le m \le 2 \times 10^5$，$2 \le k \le n$，$1 \le a_i \le n$，$1 \le x,y \le n$。

<h4>输入样例1：</h4>

<pre><code>
5 5 3
1 3 5
1 2
2 3
3 4
3 5
2 4
</code></pre>

<h4>输出样例1：</h4>

<pre><code>
3
</code></pre>

<h4>输入样例2：</h4>

<pre><code>
5 4 2
2 4
1 2
2 3
3 4
4 5
</code></pre>

<h4>输出样例2：</h4>

<pre><code>
3
</code></pre>

```cpp
```
