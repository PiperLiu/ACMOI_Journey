
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [k显性字符（思维题）](#k显性字符思维题)
- [01串（前缀和+动态规划）](#01串前缀和动态规划)

<!-- /code_chunk_output -->

没参加。

T2 有点难想。

### k显性字符（思维题）

给定一个由小写字母构成的字符串 $s$。

字符 $c$ 被称为字符串 $s$ 的 $k$ 显性字符，当且仅当字符串 $s$ 的所有长度不小于 $k$ 的子串都包含字符 $c$。

对于给定的字符串 $s$，请你找到一个最小的 $k$，使得 $s$ 中至少存在一个 $k$ 显性字符。

<h4>输入格式</h4>

一个由小写字母构成的字符串 $s$。

<h4>输出格式</h4>

一个整数，表示 $k$ 的最小可能值。

<h4>数据范围</h4>

- 前 $6$ 个测试点满足 $1 \le |s| \le 10$。
- 所有测试点满足 $1 \le |s| \le 10^5$。

<h4>输入样例1：</h4>

```
abacaba
```

<h4>输出样例1：</h4>

```
2
```

<h4>输入样例2：</h4>

```
zzzzz
```

<h4>输出样例2：</h4>

```
1
```

<h4>输入样例3：</h4>

```
abcde
```

<h4>输出样例3：</h4>

```
3
```

```cpp
// 枚举 26 个字母，求每个字母最大间隔 t
// 则对于每个字母，取 k = t + 1
// 最终选一个最小的 k ，时间复杂度 O(26n)
// 优化一下：不用跑 26 次，跑 1 次就行
// 用 last[c] 存上一次 c 出现的位置
// 则两个 c 间距就是 i - last[c]
// 注意特判开头和结尾：
// - 字符串索引从 1 开始， last 初始值为 0
// - 与开头的间距就是与 0 的间距，与末尾的就是与 n + 1 的
#include <iostream>
#include <cstring>
using namespace std;

const int N = 26, M = 1e5 + 10;
char g[M];
int last[N], d[N];  // d 各字母最大距离

int main()
{
    scanf("%s", g + 1);
    int n = strlen(g + 1);
    
    for (int i = 1; i <= n; ++ i)
    {
        int c = g[i] - 'a';
        d[c] = max(d[c], i - last[c]);
        last[c] = i;
    }
    
    for (int i = 0; i < 26; ++ i)
        d[i] = max(d[i], n + 1 - last[i]);
    
    int res = M + 1;
    for (int i = 0; i < 26; ++ i)
        res = min(d[i], res);
    
    cout << res << endl;
}
```

### 01串（前缀和+动态规划）

给定一个整数 $k$。

现在，我们可以对 $01$ 字符串进行如下操作：

选择其中<strong>恰好</strong> $k$ 个<strong>连续</strong>的 $1$，将它们都变为 $0$。

如果一个 $01$ 字符串可以通过若干次上述操作，变为一个全 $0$ 字符串，那么就称这个字符串很优秀。

本题共需要回答 $T$ 组询问，每组询问给定两个整数 $l,r$，并请你计算长度在 $[l,r]$ 范围内的所有 $01$ 字符串中优秀字符串的数量。

<h4>输入格式</h4>

第一行包含两个整数 $T$ 和 $k$。

接下来 $T$ 行，每行包含两个整数 $l,r$。

<h4>输出格式</h4>

共 $T$ 行，第 $i$ 行输出第 $i$ 组询问的答案对 $10^9+7$ 取模后的结果。

<h4>数据范围</h4>

- 前三个测试点满足 $1 \le T,k \le 10$。
- 所有测试点满足 $1 \le T,k \le 10^5$，$1 \le l \le r \le 10^5$。

<h4>输入样例：</h4>

```
3 2
1 3
2 3
4 4
```

<h4>输出样例：</h4>

```
6
5
5
```

```cpp
// 长度区间 [l, r] 因此想到前缀和
// 那下面就是如何求长度为 i 的01串中优秀的数量？动态规划
// f[i] 所有长度为 i 的优秀串的数量
// f[i] 状态转移：集合划分为 2 种
// - 第 i 位是 0 ，则从 f[i - 1] 直接转移到 f[i]
// - 第 i 位是 1 ，则最后需要连续 k 位是 1 ，从 f[i - k] 转移
// 因此状态转移是 f[i] = f[i - 1] + f[i - k]
// 边界条件注意 f[0] = 1 ，这样保证了递推关系
// 或者说 f[0] = 1 即为一次都不操作，且字符串长度为 0
#include <iostream>
using namespace std;

const int N = 1e5 + 10, MOD = 1e9 + 7;
int f[N], T, k;

int main()
{
    scanf("%d %d", &T, &k);
    f[0] = 1;
    for (int i = 1; i < N; ++ i)
    {
        if (i >= k) f[i] = f[i - k];
        f[i] = (f[i] + f[i - 1]) % MOD;
    }
    // 前缀和
    for (int i = 1; i < N; ++ i)
        f[i] = (f[i] + f[i - 1]) % MOD;
    
    while (T --)
    {
        int l, r;
        scanf("%d%d", &l, &r);
        printf("%d\n", (f[r] - f[l - 1] + MOD) % MOD);
    }
}
```

**经验：**
- 负数取模 `(val + MOD) % MOD`
