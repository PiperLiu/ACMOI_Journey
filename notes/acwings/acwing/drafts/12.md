
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [数组去重](#数组去重)
- [构造字符串](#构造字符串)
- [环形数组](#环形数组)

<!-- /code_chunk_output -->

没参加。

### 数组去重

给定一个长度为 $n$ 的整数数组 $a_1,a_2,...,a_n$。

<p>现在要进行数组去重。</p>

<p>对于数值相同的元素，只保留位于数组最右边的那个。</p>

<p>去重完成后，剩余所有元素的相对位置应保持不变。</p>

<p>输出去重后的数组。</p>

<h4>输入格式</h4>

第一行包含整数 $T$，表示共有 $T$ 组测试数据。

每组数据第一行包含整数 $n$。

第二行包含 $n$ 个整数 $a_1,a_2,...,a_n$。

<h4>输出格式</h4>

<p>每组数据输出占两行，第一行输出去重后的数组长度，第二行输出去重后的数组。</p>

<p>整数之间单个空格隔开。</p>

<h4>数据范围</h4>

- 前三个测试点满足 $1 \le n \le 6$。
- 所有测试点满足 $1 \le T \le 20$，$1 \le n \le 50$，$1 \le a_i \le 1000$。

<h4>输入样例1：</h4>

<pre><code>
1
6
1 5 5 1 6 1
</code></pre>

<h4>输出样例1：</h4>

<pre><code>
3
5 6 1 
</code></pre>

<h4>输入样例2：</h4>

<pre><code>
1
5
2 4 2 4 4
</code></pre>

<h4>输出样例2：</h4>

<pre><code>
2
2 4 
</code></pre>

<h4>输入样例3：</h4>

<pre><code>
1
5
6 6 6 6 6
</code></pre>

<h4>输出样例3：</h4>

<pre><code>
1
6
</code></pre>

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <unordered_set>
#include <vector>
using namespace std;

const int N = 1010;
int a[N];

int main()
{
    int T;
    cin >> T;
    while (T --)
    {
        int n;
        cin >> n;
        for (int i = 0; i < n; ++ i) scanf("%d", &a[i]);
        unordered_set<int> hash;
        vector<int> res;
        for (int i = n - 1; i >= 0; -- i)
        {
            if (!hash.count(a[i]))
            {
                res.push_back(a[i]);
                hash.insert(a[i]);
            }
        }
        reverse(res.begin(), res.end());
        printf("%d\n", res.size());
        for (int i = 0; i < res.size(); i ++ )
            printf("%d ", res[i]);
        puts("");
    }
}
```

我用了一些数据结构，如上。而 y 总的代码使用了两层 `for` 循环（可能是考虑到 $n$ 不是很大），当 `w[i] == w[j]` 时，就把 `w[i]` 置为 `-1` 。而我是直接从右往左遍历的，时间复杂度更低。

### 构造字符串

给定一个长度为 $n$ 的由小写字母构成的字符串 $s$。

请你构造一个长度为 $k$ 的由小写字母构成的字符串 $t$。

要求，字符串 $t$ 需满足：
- 字符串 $t$ 在字典序上大于字符串 $s$。
- 字符串 $t$ 的字母集是字符串 $s$ 的字母集的子集。一个字符串的字母集是指该字符串包含的所有不同字母的集合，例如 <code>abadaba</code> 的字母集为 $\{a,b,d\}$。
- 字符串 $t$ 在字典序上尽可能小。

<p>保证答案存在。</p>

<h4>输入格式</h4>

第一行包含整数 $T$，表示共有 $T$ 组测试数据。

每组数据第一行包含两个整数 $n$ 和 $k$。

第二行包含一个长度为 $n$ 的字符串表示 $s$。

<h4>输出格式</h4>

每组数据输出一行满足所有条件的字符串 $t$。

<h4>数据范围</h4>

- 前三个测试点满足 $1 \le n,k \le 3$。
- 所有测试点满足 $1 \le T \le 10$，$1 \le n,k \le 10^5$。
- 同一测试点内，所有 $n$ 的和不超过 $10^5$，所有 $k$ 的和不超过 $10^5$。

<h4>输入样例：</h4>

<pre><code>
4
3 3
abc
3 2
abc
3 3
ayy
2 3
ba
</code></pre>

<h4>输出样例：</h4>

<pre><code>
aca
ac
yaa
baa
</code></pre>

思路：分情况讨论
- 当 k 大于 n 时，前 n 位不变，我们让 n 位开始填补出现过的最小字符就行
- 当 k 小于等于 n 时，我们从原字符串 k - 1 位开始往前找，如果当前字符还有变小的可能，那么就让其变小，寻找停止，输出新字符串

```cpp

```

### 环形数组

给定一个长度为 $n$ 的<strong>环形数组</strong> $a_0,a_1,...,a_{n-1}$。

现在要对该数组进行 $m$ 次操作。

操作分为以下两种：
- 增值操作 <code>l r d</code>，将区间 $[l,r]$ 上的每个元素都增加 $d$。</li>
- 求最小值操作 <code>l r</code>，输出区间 $[l,r]$ 内的所有元素的最小值。

注意，数组是环形的，所以当 $n=5$ 时，区间 $[3,1]$ 内的所有元素依次为 $a_3,a_4,a_0,a_1$。

<h4>输入格式</h4>

第一行包含整数 $n$，表示数组长度。

第二行包含 $n$ 个整数，表示 $a_0,a_1,...,a_{n-1}$。

第三行包含整数 $m$，表示操作数。

接下来 $m$ 行，每行描述一个操作，对于第 $i$ 行，如果包含两个整数 $l,r$，则表示第 $i$ 个操作为求最小值操作；如果包含三个整数 $l,r,d$，则表示第 $i$ 个操作为增值操作。

<h4>输出格式</h4>

<p>每个求最小值操作输出一行结果。</p>

<h4>数据范围</h4>

- 前三个测试点满足 $1 \le n,m \le 10$。
- 所有测试点满足 $1 \le n \le 2 \times 10^5$，$0 \le m \le 2 \times 10^5$，$-10^6 \le a_i \le 10^6$，$0 \le l,r \le n-1$，$-10^6 \le d \le 10^6$。

<h4>输入样例：</h4>

<pre><code>
4
1 2 3 4
4
3 0
3 0 -1
0 1
2 1
</code></pre>

<h4>输出样例：</h4>

<pre><code>
1
0
0
</code></pre>

```cpp

```
