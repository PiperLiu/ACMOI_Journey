
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [完全平方数](#完全平方数)
- [传送阵（flood filled）](#传送阵flood-filled)
- [取石子游戏（博弈+找规律/证明/打表）](#取石子游戏博弈找规律证明打表)

<!-- /code_chunk_output -->

没参加。

### 完全平方数

给定一个长度为 $n$ 的整数数组 $a_1,a_2,...,a_n$。

请你找出其中最大的<strong>不是</strong>完全平方数的数。

如果一个整数 $a$ 是某一个整数 $b$ 的平方，那么这个整数 $a$ 叫做完全平方数。

<h4>输入格式</h4>

第一行包含整数 $n$。

第二行包含 $n$ 个整数 $a_1,a_2,...,a_n$。

<h4>输出格式</h4>

一个整数，表示数组中的最大非完全平方数。

保证一定有解。

<h4>数据范围</h4>

- 前三个测试点满足，$1 \le n \le 10$。
- 所有测试点满足，$1 \le n \le 1000$，$-10^6 \le a_i \le 10^6$。

<h4>输入样例1：</h4>

```
2
4 2
```

<h4>输出样例1：</h4>

```
2
```

<h4>输入样例2：</h4>

```
8
1 2 4 8 16 32 64 576
```

<h4>输出样例2：</h4>

```
32
```

```cpp
#include <iostream>
#include <cmath>
using namespace std;

const int N = 1010;
int a, n;

int
main ()
{
    cin >> n;
    int ans = -1e7;
    for (int i = 0; i < n; ++ i)
    {
        cin >> a;
        int t = sqrt(a);
        if (a < 0 && a > ans) ans = a;
        if (a < 0) continue;
        if (t * t != a && a > ans) ans = a;
    }
    cout << ans;
    return 0;
}
```

### 传送阵（flood filled）

给定一个 $n \times n$ 的方格矩阵，行、列编号为 $1 \sim n$，其中第 $i$ 行第 $j$ 列的方格坐标为 $(i,j)$。

每个方格要么是平地，要么是陷阱。

旅行者从方格 $(r_1,c_1)$ 出发，要前往方格 $(r_2,c_2)$ 处。

出发点和目的地保证都是平地。

旅行者每次移动可以沿上、下、左、右四个方向，移动一格距离。

移动过程中，不得走出矩阵或进入陷阱。

由于存在陷阱的原因，旅行者可能无法顺利抵达目的地。

幸运的是，他可以任意选择两个<strong>平地</strong>方格，在上面建立一对传送阵。

传送阵能够支持旅行者在两个平地方格之间自由传送。

但是，建立传送阵是一笔不容小视的花费。

在方格 $(r_s,c_s)$ 和 $(r_t,c_t)$ 处建立传送阵，所需成本为 $(r_s-r_t)^2+(c_s-c_t)^2$。

请你计算，为了使旅行者能够成功抵达目的地，建立传送阵所需花费的最低成本。

如果旅行者可以无需建立传送阵，直接走到目的地，那么成本就是 $0$。

注意，最多只能建立一对传送阵。

<h4>输入格式</h4>

第一行包含整数 $n$，表示矩阵尺寸。

第二行包含两个整数 $r_1,c_1$，表示起点方格坐标为 $(r_1,c_1)$。

第三行包含两个整数 $r_2,c_2$，表示目的地方格坐标为 $(r_2,c_2)$。

接下来 $n$ 行，每行包含一个长度为 $n$ 的 $01$ 字符串，其中第 $i$ 行第 $j$ 个字符如果为 $0$，则表示方格 $(i,j)$ 是平地，如果为 $1$，则表示方格 $(i,j)$ 是陷阱。

<h4>输出格式</h4>

输出一个整数，表示为了确保旅行能够成功，所需花费的最小成本。

<h4>数据范围</h4>

- 前三个测试点满足，$1 \le n \le 10$。
- 所有测试点满足，$1 \le n \le 50$，$1 \le r_1,c_1,r_2,c_2 \le n$。

<h4>输入样例1：</h4>

```
5
1 1
5 5
00001
11111
00111
00110
00110
```

<h4>输出样例1：</h4>

```
10
```

<h4>输入样例2：</h4>

```
3
1 3
3 1
010
101
010
```

<h4>输出样例2：</h4>

```
8
```

<h4>输入样例3：</h4>

```
1
1 1
1 1
0
```

<h4>输出样例3：</h4>

```
0
```

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 55;

int n;
char g[N][N];
int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
bool st1[N][N], st2[N][N];  // 与起点连通的点，与终点连通的点

void dfs(int x, int y, bool st[][N])  // flood fill 用 bfs 也行
{
    st[x][y] = true;
    for (int i = 0; i < 4; i ++ )
    {
        int a = x + dx[i], b = y + dy[i];
        if (a >= 0 && a < n && b >= 0 && b < n && !st[a][b] && g[a][b] == '0')
            dfs(a, b, st);
    }
}

int main()
{
    cin >> n;
    int sx, sy, tx, ty;
    cin >> sx >> sy >> tx >> ty;
    sx --, sy --, tx --, ty -- ;  // 从 0 开始
    for (int i = 0; i < n; i ++ ) cin >> g[i];

    dfs(sx, sy, st1);
    if (st1[tx][ty]) puts("0");  // 要是起点终点连通，不用建传送门
    else
    {
        dfs(tx, ty, st2);  // 看看终点连通块
        int res = 1e8;
        for (int i = 0; i < n; i ++ )
            for (int j = 0; j < n; j ++ )
                if (st1[i][j])  // 遍历起点终点的连通块，暴搜
                    for (int x = 0; x < n; x ++ )
                        for (int y = 0; y < n; y ++ )
                            if (st2[x][y])
                                res = min(res, (i - x) * (i - x) + (j - y) * (j - y));

        cout << res << endl;
    }

    return 0;
}
```

### 取石子游戏（博弈+找规律/证明/打表）

Alice 和 Bob 正在玩一个取石子游戏。

共有 $n$ 个石子，双方轮流采取行动。

每当轮到一人行动时，该名玩家需要从石子堆中取走<strong>恰好</strong> $1$ 或 $2$ 或 $k$ 个石子。

如果轮到一人行动时，已经没有石子可取，则该名玩家失败。

已知，双方都会采取最优策略，且 Alice 率先行动。

请问，最终谁将获胜。

<h4>输入格式</h4>

第一行包含整数 $T$，表示共有 $T$ 组测试数据。

每组数据占一行，包含两个整数 $n,k$。

<h4>输出格式</h4>

每组数据输出一行结果，如果 Alice 获胜，则输出 `Alice`，否则输出 `Bob`。

<h4>数据范围</h4>

- 前三个测试点满足，$1 \le T \le 10$。
- 所有测试点满足，$1 \le T \le 100$，$0 \le n \le 10^9$，$3 \le k \le 10^9$。

<h4>输入样例：</h4>

```
4
0 3
3 3
3 4
4 4
```

<h4>输出样例：</h4>

```
Bob
Alice
Bob
Alice
```

**遇到博弈的题，假设最多取 k 个石子，就拿 0,...,k 个石子的情况找规律。**

转自大佬[灵茶山艾府](https://www.acwing.com/activity/content/code/content/1971096/)：

考虑哪些 $n$ 会导致先手必败。

如果只考虑取 $1$ 和 $2$，那么若 $n$ 是 $3$ 的倍数，先手取 $x$ 个石子，后手就可以取 $3−x$ 个石子，这样剩下的石子仍然是 $3$ 的倍数，所以先手必败；若 $n$ 不是 $3$ 的倍数，先手可以将石子个数变成 $3$ 的倍数，这样后手必败，先手必胜。

接下来考虑取 $1$，$2$ 和 $k$。上面的讨论启发我们去讨论 $k$ 与 $3$ 的关系：

如果 $k$ 不是 $3$ 的倍数，那么若 $n$ 是 $3$ 的倍数，先手取 $x$ 个石子，后手就可以取 $3−(x\; mod\; 3)$ 个石子，这样剩下的石子仍然是 $3$ 的倍数，所以先手必败；若 $n$ 不是 $3$ 的倍数，先手可以将石子个数变成 $3$ 的倍数，这样后手必败，先手必胜。因此在 $k$ 不是 $3$ 的倍数的情况下，仍然同上面一样，当 $n$ 是 $3$ 的倍数时先手必败，否则先手必胜。

如果 $k$ 是 $3$ 的倍数，那么显然 $n=k$ 时是先手必胜的，而 $n=k+1$ 时由于可以到达的 $k$、$k−1$ 和 $1$ 均为先手必胜，所以此时先手必败。$n=k+2$ 和 $n=k+3$ 时，由于可以到达 $k+1$，所以是先手必胜的，再往后的讨论和上面一样，直到 $n=2k+1$ 时由于可以直接到 $k+1$ 的必败态所以此时是先手必胜的，这样就形成了一个从 $0$ 开始的长为 $k+1$ 的循环，循环的最后一个数是先手必胜的，其余数转化成在循环中的位置，按上面讨论的是否为 $3$ 的倍数判断胜负。

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

int main()
{
    int T;
    cin >> T;
    while (T -- )
    {
        int n, k;
        cin >> n >> k;
        if (k % 3)  // k 不是 3 的倍数
        {
            if (n % 3) puts("Alice");
            else puts("Bob");
        }
        else  // k 是 3 的倍数
        {
            n %= k + 1;  // 进入 0, ..., k 的讨论中
            if (n == k || n % 3) puts("Alice");  // 先手必胜， 对于先手 n % 3 时可抵达 k*常数 的情况
            else puts("Bob");
        }
    }

    return 0;
}
```

附：如何打表。

这里用 SG 函数打表找规律。

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1010;

int sg[N];

int main()
{
    int n, k;
    cin >> n >> k;
    for (int i = 1; i <= n; ++ i)
    {
        bool st[4] = {0};
        int d[] = {1, 2, k};
        for (int j: d)
            if (j <= i)
                st[sg[i - j]] = true;
        
        for (int j = 0;; ++ j)
            if (!st[j])
            {
                sg[i] = j;
                break;
            }
    }
    
    for (int i = 0; i <= n; ++ i)
    {
        cout << sg[i] << ' ';
        if (i % (k + 1) == k) cout << endl;
    }
    cout << endl;
    
    return 0;
}

// 100 8
/*
0 1 2 0 1 2 0 1 2 
0 1 2 0 1 2 0 1 2 
0 1 2 0 1 2 0 1 2 
0 1 2 0 1 2 0 1 2 
0 1 2 0 1 2 0 1 2 
0 1 2 0 1 2 0 1 2 
0 1 2 0 1 2 0 1 2 
0 1 2 0 1 2 0 1 2 
0 1 2 0 1 2 0 1 2 
0 1 2 0 1 2 0 1 2 
0 1 2 0 1 2 0 1 2 
0 1 
*/

// 30 5
/*
0 1 2 0 1 2 
0 1 2 0 1 2 
0 1 2 0 1 2 
0 1 2 0 1 2 
0 1 2 0 1 2 
0 
*/
```
