
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [排位](#排位)
- [训练（考察分析）](#训练考察分析)
- [构造数组（数奥思维：可重集组合问题+动态规划）](#构造数组数奥思维可重集组合问题动态规划)

<!-- /code_chunk_output -->

没参加。

### 排位

有 $n$ 个人排成了一队，小明就在其中。

他不知道自己的确切排位，但是他能确定的是，排在他前面的人不少于 $a$ 个，排在他后面的人不超过 $b$ 个。

请问，对于他的具体排位，一共有多少种可能性？

<h4>输入格式</h4>

第一行包含整数 $T$，表示共有 $T$ 组数据。

每组数据占一行，包含三个整数 $n,a,b$。

<h4>输出格式</h4>

每组数据输出一行结果，一个整数，表示小明具体排位的可能数量。

<h4>数据范围</h4>

- 本题共两个测试点。
- 小测试点，如样例所示。
- 大测试点满足：$1≤T≤50$，$0 \le a,b < n \le 100$。

<h4>输入样例：</h4>

```
2
3 1 1
5 2 3
```

<h4>输出样例：</h4>

```
2
3
```

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int main()
{
    int T;
    int a, b, n;
    cin >> T;
    while (T --)
    {
        cin >> n >> a >> b;
        cout << min(n - a, b + 1) << endl;
    }
}
```

### 训练（考察分析）

达尔星有 $n$ 个强大的下级战士，编号 $1 \sim n$。

其中第 $i$ 名战士的战斗力为 $r_i$。

战士 $a$ 可以成为战士 $b$ 的战斗导师，当且仅当 $r_a > r_b$ 且两人之间不存在矛盾。

给定每个战士的战斗力值以及战士之间存在的 $k$ 对矛盾关系。

请你计算，每个战士可以成为多少战士的战斗导师。

<h4>输入格式</h4>

第一行包含两个整数 $n$ 和 $k$。

第二行包含 $n$ 个整数 $r_1,r_2,...,r_n$。

接下来 $k$ 行，每行包含两个整数 $x,y$，表示战士 $x$ 和战士 $y$ 之间存在矛盾。同一对矛盾关系不会在输入中重复给出，即出现了 $x,y$ 以后，后面就不会再次出现 $x,y$ 或 $y,x$。

<h4>输出格式</h4>

共一行，$n$ 个整数，表示每个战士可以作为战斗导师的战士数量。

<h4>数据范围</h4>

- 前三个测试点满足，$2 \le n \le 10$，$0 \le k \le 10$。
- 所有测试点满足，$2 \le n \le 2 \times 10^5$，$0 \le k \le \min(2 \times 10^5,\frac{n(n-1)}{2})$，$1 \le r_i \le 10^9$，$1 \le x,y \le n$，$x \neq y$。

<h4>输入样例：</h4>

```
4 2
10 4 10 15
1 2
4 3
```

<h4>输出样例：</h4>

```
0 0 1 2
```

```cpp
// 审题没想到考察啥知识点
// 由数据范围算法复杂度应该是 nlogn
// 稍加分析：
// - 数组排序，然后看有多少个数小于它就容易了（每个数二分）
// - 如何把矛盾考虑在内？
// - 预处理一下，如果发现 a 与 b 有矛盾，且 r[a] > r[b]
//   则 cnt[a] ++ 代表 a 少招一个学生
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 2e5 + 10;
int a[N], b[N], cnt[N];
int n, k;

int
main()
{
    cin >> n >> k;
    for (int i = 1; i <= n; ++ i)
    {
        int p;
        cin >> p;
        a[i] = b[i] = p;
    }
    
    for (int i = 0; i < k; ++ i)
    {
        int p1, p2;
        cin >> p1 >> p2;
        if (a[p1] > a[p2]) cnt[p1] ++ ;
        else if (a[p1] < a[p2]) cnt[p2] ++ ;
    }
    
    sort(b + 1, b + n + 1);  // 注意从 b + 1 开始
    
    for (int i = 1; i <= n; ++ i)
    {
        // 也可以用
        // int k = lower_bound(b + 1, b + n + 1, a[i]) - b;  // 注意这里返回的指针
        int l = 1, r = n, mid = l + r >> 1;
        while (l < r)
        {
            mid = l + r >> 1;
            if (b[mid] >= a[i]) r = mid;
            else l = mid + 1;
        }
        cout << l - 1 - cnt[i] << " ";
    }
}
```

### 构造数组（数奥思维：可重集组合问题+动态规划）

现在需要构造一对数组 $(a,b)$，要求：

- 数组 $a$ 和数组 $b$ 的长度都为 $m$。
- 两个数组中的元素的取值范围都是 $[1,n]$。
- $\forall i \in [1,m]$，$a_i \le b_i$。
- 数组 $a$ 中元素非严格单调递增。
- 数组 $b$ 中元素非严格单调递减。

请问，共能构造出多少对满足条件的数组？

输出对 $10^9+7$ 取模后的结果。

<h4>输入格式</h4>

一行，两个整数 $n,m$。

<h4>输出格式</h4>

一个整数，表示满足条件的数组对的数量对 $10^9+7$ 取模后的结果。

<h4>数据范围</h4>

- 前三个测试点满足，$1 \le n,m \le 10$。
- 所有测试点满足，$1 \le n \le 1000$，$1 \le m \le 10$。

<h4>输入样例：</h4>

```
2 2
```

<h4>输出样例：</h4>

```
5
```

```cpp
// 第一眼看以为会用到单调栈，实际上不是的
// 转换题意1：在数轴上取 2m 个数，则一定对应唯一一对符合题意数组
//     （前 m 个是 b 后 m 个是 a）
// 转换题意2：因此可以转换成不定方程有多少个解（数奥思维）
//     设数 i 被选了 xi 次，则 x1 + x2 + ... + xn = 2m , xi 是自然数
// 转换题意3：设 xi' = xi + 1 则
//     x1' + x2' + ... xn' = 2m + n , xi' 是正整数
// 转换题意4：隔板法，因为 xi' 是正整数了，则相当于在 2m + n 个小球
//     之间放 n 个板子，且不能相邻放板子、不能把板子放在最两侧
// 因此本题就是求 C_{2m+n-1}^{n-1} = C_{2m+n-1}^{2m}
// 利用公式 C_b^a = C_{b-1}^a + C_{b-1}^{a-1} 递推
// 则 C_{2m+n-1}^{n-1} O(n^2) 而 C_{2m+n-1}^{2m} O(mn) 用后者
// 本题考察数奥思维，偏难怪了属于是
#include <iostream>
using namespace std;

const int N = 1030, M = 30, MOD = 1e9 + 7;
int C[N][M];
int n, m;

int
main()
{
    cin >> n >> m;
    for (int i = 0; i <= 2 * m + n - 1; ++ i)
        for (int j = 0; j <= 2 * m && j <= i; ++ j)
            if (!j) C[i][j] = 1;
            else C[i][j] = (C[i-1][j] + C[i-1][j-1]) % MOD;
    
    cout << C[2 * m + n - 1][2 * m] << endl;
}
```
