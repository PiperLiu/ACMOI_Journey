<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=4 orderedList=false} -->

<!-- code_chunk_output -->

- [贪心算法](#贪心算法)
- [区间问题](#区间问题)
  - [例题：区间选点](#例题区间选点)
  - [例题：最大不相交区间数量](#例题最大不相交区间数量)
  - [例题：区间分组](#例题区间分组)

<!-- /code_chunk_output -->

### 贪心算法

贪心不但没有模板，还没有套路。

算法虽然简单，但是想证明正确性很难。所以 y总 觉得最难。

### 区间问题

#### 例题：区间选点

- 给定 N 个闭区间 $[a_i,b_i]$，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。
- 输出选择的点的最小数量。
- 位于区间端点上的点也算作区间内。

输入格式
- 第一行包含整数 N，表示区间数。
- 接下来 N 行，每行包含两个整数 $a_i,b_i$，表示一个区间的两个端点。

输出格式
- 输出一个整数，表示所需的点的最小数量。

数据范围
- $1≤N≤10^5$
- $−10^9≤a_i≤b_i≤10^9$

**分析：**

![](./images/20210612greedy.png)

如何证明上述贪心算法是对的？
- 假设 `cnt` 为保证符合题意的选点方案的选点数量
- `ans` 为答案，即所需的点的最小数量
- 则一定有 `ans = min({cnt}) <= cnt`
- 而考虑没有被 pass 的区间，这些区间一定两两不相交，则这些区间有 `cnt` 个，而要通过选点将其覆盖，则必须至少有 `ans` 个区间，即 `ans >= cnt`
- 所以 `ans=cnt` 得证

```cpp
```

#### 例题：最大不相交区间数量

- 给定 N 个闭区间 $[a_i,b_i]$，请你在数轴上选择若干区间，使得选中的区间之间互不相交（包括端点）。
- 输出可选取区间的最大数量。

输入格式
- 第一行包含整数 N，表示区间数。
- 接下来 N 行，每行包含两个整数 $a_i,b_i$，表示一个区间的两个端点。

输出格式
- 输出一个整数，表示可选取区间的最大数量。

数据范围
- $1≤N≤10^5$
- $−10^9≤a_i≤b_i≤10^9$

**分析：**
- 和上一道题一模一样
- 参考[Shadow](https://www.acwing.com/solution/content/5749/)：为什么最大不相交区间数==最少覆盖区间点数呢？因为如果几个区间能被同一个点覆盖，说明他们相交了，所以有几个点就是有几个不相交区间

```cpp

```

#### 例题：区间分组

- 给定 N 个闭区间 $[a_i,b_i]$，请你将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小。
- 输出最小组数。

输入格式
- 第一行包含整数 N，表示区间数。
- 接下来 N 行，每行包含两个整数 $a_i,b_i$，表示一个区间的两个端点。

输出格式
- 输出一个整数，表示最小组数。

数据范围
- $1≤N≤10^5$
- $−10^9≤a_i≤b_i≤10^9$

**分析：**

![](./images/20210612greedy2.png)

- 将所有区间按照左端点从小到大排序
- 从前往后处理每个区间 `i`
  - 判断能否将其放到某个现有的组中 `L[i] > Max_r[组]`
    - 如果存在能放进去的组，则将其放进去（随便挑一个能放的就行），并且更新当前组 `Mar_r`
    - 如果不存在这样的组，则开新组，将区间 `i` 放进去

**证明：**
- 首先，这种方式一定是合法方案
- `ans <= cnt` 因为 `ans` 是合法方案的最小值
- `ans >= cnt` 因为对于 `cnt` 个组来说，其有公共点，则必须至少有 `ans` 个区间

```cpp
```

##### 更妙的方式：活动安排教室

参考[未来](https://www.acwing.com/solution/content/8902/)：

看了一下，貌似是求最大区间厚度的问题。大家可以把这个问题想象成活动安排问题。

有若干个活动，第i个活动开始时间和结束时间是$[S_i,f_i]$，同一个教室安排的活动之间不能交叠，求要安排所有活动，少需要几个教室？

有时间冲突的活动不能安排在同一间教室，与该问题的限制条件相同，即最小需要的教室个数即为该题答案。

我们可以把所有开始时间和结束时间排序，遇到开始时间就把需要的教室加1，遇到结束时间就把需要的教室减1,在一系列需要的教室个数变化的过程中，峰值就是多同时进行的活动数，也是我们至少需要的教室数。

```cpp
```

![](./images/20210612greedy3.png)

> 学到 1:09
