# Tire字典树

<!-- @import "[TOC]" {cmd="toc" depthFrom=3 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [前缀统计](#前缀统计)

<!-- /code_chunk_output -->

### 前缀统计

给定 $N$ 个字符串 $S_1,S_2 ... S_N$，接下来进行 $M$ 次询问，每次询问给定一个字符串 $T$，求 $S_1 \sim S_N$ 中有多少个字符串是 $T$ 的前缀。

输入字符串的总长度不超过 $10^6$，仅包含小写字母。

<h4>输入格式</h4>

第一行输入两个整数 $N，M$。

接下来 $N$ 行每行输入一个字符串 $S_i$。

接下来 $M$ 行每行一个字符串 $T$ 用以询问。

<h4>输出格式</h4>

<p>对于每个询问，输出一个整数表示答案。</p>

<p>每个答案占一行。</p>

<h4>输入样例：</h4>

<pre><code>
3 2
ab
bc
abc
abc
efg
</code></pre>

<h4>输出样例：</h4>

<pre><code>
2
0
</code></pre>

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 1e6 + 10;

int son[N][26];
int cnt[N];
int idx;

void insert(char str[])
{
    int p = 0;
    for (int i = 0; str[i]; ++ i)
    {
        int u = str[i] - 'a';
        if (!son[p][u]) son[p][u] = ++ idx;
        p = son[p][u];
    }
    cnt[p] ++;
}

int query(char str[])
{
    int p = 0, res = 0;
    for (int i = 0; str[i]; ++ i)
    {
        int u = str[i] - 'a';
        if (!son[p][u]) break;
        p = son[p][u];
        res += cnt[p];
    }
    return res;
}

int main()
{
    int n, m;
    cin >> n >> m;
    char x[N];
    for (int i = 0; i < n; i ++ )
    {
        scanf("%s", x);
        insert(x);
    }
    
    for (int i = 0; i < m; ++ i)
    {
        scanf("%s", x);
        printf("%d\n", query(x));
    }
}
```
