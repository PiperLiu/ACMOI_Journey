
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [约数之和](#约数之和)

<!-- /code_chunk_output -->

### 约数之和

假设现在有两个自然数 $A$ 和 $B$，$S$ 是 $A^B$ 的所有约数之和。

请你求出 $S \bmod 9901$ 的值是多少。

<h4>输入格式</h4>

在一行中输入用空格隔开的两个整数 $A$ 和 $B$。

<h4>输出格式</h4>

输出一个整数，代表 $S \bmod 9901$ 的值。

<h4>数据范围</h4>

$0 \le A,B \le 5 \times 10^7$

<h4>输入样例：</h4>
<pre><code>2 3
</code></pre>

<h4>输出样例：</h4>
<pre><code>15
</code></pre>

<strong>注意</strong>: $A$ 和 $B$ 不会同时为 $0$。

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;
typedef long long LL;

const int mod = 9901;

int qmi(int a, int k)
{
    int res = 1 % mod;
    while (k)
    {
        if (k & 1) res = (LL)res * a % mod;
        a = (LL)a * a % mod;
        k >>= 1;
    }
    return res;
}

// 这里的 k 与题解的略有不同
// 这里是 0, ..., k
// 题解是 0, ..., k - 1
int sum(int p, int k)
{
    if (k == 0) return 1;
    // 0 到 k 有偶数项个（即 k 是奇数）
    if (k % 2 == 0) return (p % mod * sum(p, k - 1) % mod + 1) % mod;
    // k 是偶数
    return (qmi(p, k / 2 + 1) + 1) % mod * sum(p, k / 2) % mod;
}

int main()
{
    int A, B;
    cin >> A >> B;
    int res = 1;
    // 注意这里是 i <= A ，而非 i <= A / i
    // 因为这里包含了 A 本身是质数（为2）的情况
    for (int i = 2; i <= A; ++ i)
    {
        int s = 0;
        while (A % i == 0)
        {
            s ++;
            A /= i;
        }
        if (s) res = res * sum(i, s * B) % mod;
    }
    if (!A) res = 0;
    printf("%d", res);
}
```

对于数字 $N$ ，可以因式分解如下：
$$N = p_1^{\alpha_1} p_2^{\alpha_2} ... p_k^{\alpha_k}$$

其约数总可以唯一地分解为：
$$d = p_1^{\beta_1} p_2^{\beta_2} ... p_k^{\beta_k}$$

且 $0 \le \beta_i \le \alpha_i$

因此，对于每一个 $\beta_i$ ，其取值范围为 $[0, \alpha_i]$ 共 $\alpha_i + 1$ 个。

$N$ 的约数个数为 $(\alpha_1 + 1)(\alpha_2 + 1)...(\alpha_k + 1)$ 。

$N$ 的约数之和为 $(p_1^0 + p_1^1 + ... + p_1^{\alpha_1})...(p_k^0 + p_k^1 + ... + p_k^{\alpha_k})$ 。把公式展开，其意自现。

有了约数和的知识背景基础，下面就来介绍<strong>分治法求$p^0 + p^1 + \ldots + p^{k-1}$</strong>

<h2>思路</h2>

这里实现一个sum函数，sum(p, k)表示$p^0 + p^1 + \ldots + p^{k-1}$

<p>思路，当k为偶数时，sum(p, k)可以拆解成</p>

$$p^0 + p^1 + \ldots + p^{k/2-1} + p^{k/2} +p^{k/2 + 1} + \ldots + p^{k-1}$$
即
$$p^0 + p^1 + \ldots + p^{k/2-1} + p^{k/2} * (p^0 + p^1 + \ldots + p^{k/2-1})$$
也就是
$$sum(p, k / 2) + p^{k/2} * sum(p, k / 2)$$

<p>进一步化简</p>

$$(p^{k/2} + 1) * sum(p, k / 2)$$
当k为奇数时，为了更方便调用我们写的偶数项情况，可以单独拿出最后一项，把剩下的项转化为求偶数项的情况来考虑，再加上最后一项，就是奇数项的情况了。也即$sum(p, k - 1)+p^{k-1}$
<p>这样这个代码就写完了</p>

```cpp
//p0 + .. + pk-1
int sum(int p, int k) {
    if(k == 1) return 1;  //边界
    if(k % 2 == 0) {  
        return (LL)(qmid(p, k / 2) + 1) * sum(p, k / 2) % mod;
    }
    return (qmid(p, k - 1) + sum(p, k - 1)) % mod;
}
```
