
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [2165. 重排数字的最小值（妙用STL）](#2165-重排数字的最小值妙用stl)
- [2167. 移除所有载有违禁货物车厢所需的最少时间（前后缀分解枚举分界点+动态规划）](#2167-移除所有载有违禁货物车厢所需的最少时间前后缀分解枚举分界点动态规划)

<!-- /code_chunk_output -->

过年，没参加。

### 2165. 重排数字的最小值（妙用STL）

给你一个整数 num 。重排 num 中的各位数字，使其值 最小化 且不含 任何 前导零。

返回不含前导零且值最小的重排数字。

注意，重排各位数字后，num 的符号不会改变。

示例 1：
```
输入：num = 310
输出：103
解释：310 中各位数字的可行排列有：013、031、103、130、301、310 。
不含任何前导零且值最小的重排数字是 103 。
```

示例 2：
```
输入：num = -7605
输出：-7650
解释：-7605 中各位数字的部分可行排列为：-7650、-6705、-5076、-0567。
不含任何前导零且值最小的重排数字是 -7650 。
```

提示：
- -10e15 <= num <= 10e15

```cpp
class Solution {
public:
    long long smallestNumber(long long num) {
        if (num == 0) return num;
        string str = to_string(num);
        if (str.front() == '-')
        {
            sort(str.begin(), str.end(), [](char a, char b) {
                return a > b;
            });
            return stoll("-" + str);
        }
        sort(str.begin(), str.end());
        swap(*find_if(str.begin(), str.end(), [](char a){return a != '0';}), *str.begin());
        return stoll(str);
    }
};
```

### 2167. 移除所有载有违禁货物车厢所需的最少时间（前后缀分解枚举分界点+动态规划）

给你一个下标从 0 开始的二进制字符串 s ，表示一个列车车厢序列。s[i] = '0' 表示第 i 节车厢 不 含违禁货物，而 s[i] = '1' 表示第 i 节车厢含违禁货物。

作为列车长，你需要清理掉所有载有违禁货物的车厢。你可以不限次数执行下述三种操作中的任意一个：

- 从列车 左 端移除一节车厢（即移除 s[0]），用去 1 单位时间。
- 从列车 右 端移除一节车厢（即移除 s[s.length - 1]），用去 1 单位时间。
- 从列车车厢序列的 任意位置 移除一节车厢，用去 2 单位时间。

返回移除所有载有违禁货物车厢所需要的 最少 单位时间数。

注意，空的列车车厢序列视为没有车厢含违禁货物。

示例 1：
```
输入：s = "1100101"
输出：5
解释：
一种从序列中移除所有载有违禁货物的车厢的方法是：
- 从左端移除一节车厢 2 次。所用时间是 2 * 1 = 2 。
- 从右端移除一节车厢 1 次。所用时间是 1 。
- 移除序列中间位置载有违禁货物的车厢。所用时间是 2 。
总时间是 2 + 1 + 2 = 5 。

一种替代方法是：
- 从左端移除一节车厢 2 次。所用时间是 2 * 1 = 2 。
- 从右端移除一节车厢 3 次。所用时间是 3 * 1 = 3 。
总时间也是 2 + 3 = 5 。

5 是移除所有载有违禁货物的车厢所需要的最少单位时间数。
没有其他方法能够用更少的时间移除这些车厢。
```

示例 2：
```
输入：s = "0010"
输出：2
解释：
一种从序列中移除所有载有违禁货物的车厢的方法是：
- 从左端移除一节车厢 3 次。所用时间是 3 * 1 = 3 。
总时间是 3.

另一种从序列中移除所有载有违禁货物的车厢的方法是：
- 移除序列中间位置载有违禁货物的车厢。所用时间是 2 。
总时间是 2.

另一种从序列中移除所有载有违禁货物的车厢的方法是：
- 从右端移除一节车厢 2 次。所用时间是 2 * 1 = 2 。
总时间是 2.

2 是移除所有载有违禁货物的车厢所需要的最少单位时间数。
没有其他方法能够用更少的时间移除这些车厢。
```

提示：
- 1 <= s.length <= 2 * 10e5
- s[i] 为 '0' 或 '1'

```cpp
/** 分析：
 * 一个点只有三种情况退出，左、直接、右
 * 并且， i 点是左边出去的，那么 i 左边的点就绝不可能从右边出去
 * 因此我们可以枚举“分割点”，分割点左边的，只能左、直接两种方式出
 * 右边的，只能右、直接两种方式出
 * 左边右边的最优值怎么算？都枚举太蠢了，考虑集合关系，可以优化成动态规划
 */
class Solution {
public:
    int minimumTime(string s) {
        int n = s.size();
        vector<int> sub(n + 1, 0);
        for (int i = n - 1; i >= 0; -- i)
            if (s[i] == '1') sub[i] = min(n - i, sub[i + 1] + 2);
            else sub[i] = sub[i + 1];
        int pre = 0;
        int res = sub[0];
        for (int i = 0; i < n; ++ i)
        {
            if (s[i] == '1') pre = min(i + 1, pre + 2);
            res = min(res, pre + sub[i + 1]);
        }
        return res;
    }
};
```

```cpp
/** 还可以继续优化：
 * 左、直接、右，把直接这个归为前缀做的事，
 * 右这个交给后缀做
 */
class Solution {
public:
    int minimumTime(string s) {
        int n = s.size();
        int pre = 0;
        int ans = n;
        for (int i = 0; i < n; ++ i)
        {
            if (s[i] == '1') pre = min(pre + 2, i + 1);
            ans = min(ans, pre + n - 1 - i);
        }
        return ans;
    }
};
```
