
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [检查字符串是否为数组前缀](#检查字符串是否为数组前缀)
- [移除石子使总数最小](#移除石子使总数最小)
- [使字符串平衡的最小交换次数](#使字符串平衡的最小交换次数)
- [找出到每个位置为止最长的有效障碍赛跑路线（最长非降子序列）](#找出到每个位置为止最长的有效障碍赛跑路线最长非降子序列)

<!-- /code_chunk_output -->

最后一道题尽力分析了。倒数第二题没有思路。

### 检查字符串是否为数组前缀

给你一个字符串 s 和一个字符串数组 words ，请你判断 s 是否为 words 的 前缀字符串 。

字符串 s 要成为 words 的 前缀字符串 ，需要满足：s 可以由 words 中的前 k（k 为 正数 ）个字符串按顺序相连得到，且 k 不超过 words.length 。

如果 s 是 words 的 前缀字符串 ，返回 true ；否则，返回 false 。

示例 1：

```
输入：s = "iloveleetcode", words = ["i","love","leetcode","apples"]
输出：true
解释：
s 可以由 "i"、"love" 和 "leetcode" 相连得到。
```

示例 2：

```
输入：s = "iloveleetcode", words = ["apples","i","love","leetcode"]
输出：false
解释：
数组的前缀相连无法得到 s 。
```

提示：
- 1 <= words.length <= 100
- 1 <= words[i].length <= 20
- 1 <= s.length <= 1000
- words[i] 和 s 仅由小写英文字母组成

```cpp
class Solution {
public:
    bool isPrefixString(string s, vector<string>& words) {
        string res;
        int i;
        for (auto w: words)
        {
            res += w;
            i += w.size();
            if (res == s.substr(0, i))
            {
                if (i == s.size()) return true;
                continue;
            }
            else break;
        }
        return false;
    }
};
```

### 移除石子使总数最小

给你一个整数数组 piles ，数组 下标从 0 开始 ，其中 piles[i] 表示第 i 堆石子中的石子数量。另给你一个整数 k ，请你执行下述操作 恰好 k 次：

选出任一石子堆 piles[i] ，并从中 移除 floor(piles[i] / 2) 颗石子。
注意：你可以对 同一堆 石子多次执行此操作。

返回执行 k 次操作后，剩下石子的 最小 总数。

floor(x) 为 小于 或 等于 x 的 最大 整数。（即，对 x 向下取整）。

示例 1：

```
输入：piles = [5,4,9], k = 2
输出：12
解释：可能的执行情景如下：
- 对第 2 堆石子执行移除操作，石子分布情况变成 [5,4,5] 。
- 对第 0 堆石子执行移除操作，石子分布情况变成 [3,4,5] 。
剩下石子的总数为 12 。
```

示例 2：

```
输入：piles = [4,3,6,7], k = 3
输出：12
解释：可能的执行情景如下：
- 对第 2 堆石子执行移除操作，石子分布情况变成 [4,3,3,7] 。
- 对第 3 堆石子执行移除操作，石子分布情况变成 [4,3,3,4] 。
- 对第 0 堆石子执行移除操作，石子分布情况变成 [2,3,3,4] 。
剩下石子的总数为 12 。
```

提示：
- 1 <= piles.length <= $10^5$
- 1 <= piles[i] <= $10^4$
- 1 <= k <= $10^5$

```cpp
class Solution {
public:
    int ceil(int x)
    {
        return (x + 1) / 2;
    }
    int floor(int x)
    {
        return x / 2;
    }
    int minStoneSum(vector<int>& piles, int k) {
        priority_queue<int> q;
        int sum = 0;
        for (auto t: piles)
        {
            q.push(t);
            sum += t;
        }
        while (k --)
        {
            int t = q.top();
            q.pop();
            sum -= floor(t);
            q.push(ceil(t));
        }
        return sum;
    }
};
```

### 使字符串平衡的最小交换次数

给你一个字符串 s ，下标从 0 开始 ，且长度为偶数 n 。字符串 恰好 由 n / 2 个开括号 `'['` 和 n / 2 个闭括号 `']'` 组成。

只有能满足下述所有条件的字符串才能称为 平衡字符串 ：

字符串是一个空字符串，或者
字符串可以记作 AB ，其中 A 和 B 都是 平衡字符串 ，或者
字符串可以写成 `[C]` ，其中 C 是一个 平衡字符串 。
你可以交换 任意 两个下标所对应的括号 任意 次数。

返回使 s 变成 平衡字符串 所需要的 最小 交换次数。

示例 1：

```
输入：s = "][]["
输出：1
解释：交换下标 0 和下标 3 对应的括号，可以使字符串变成平衡字符串。
最终字符串变成 "[[]]" 。
```

示例 2：

```
输入：s = "]]][[["
输出：2
解释：执行下述操作可以使字符串变成平衡字符串：
- 交换下标 0 和下标 4 对应的括号，s = "[]][[]" 。
- 交换下标 1 和下标 5 对应的括号，s = "[[][]]" 。
最终字符串变成 "[[][]]" 。
```

示例 3：

```
输入：s = "[]"
输出：0
解释：这个字符串已经是平衡字符串。
```

提示：
- n == s.length
- 2 <= n <= $10^6$
- n 为偶数
- s[i] 为'[' 或 ']'
- 开括号 '[' 的数目为 n / 2 ，闭括号 ']' 的数目也是 n / 2

```cpp
class Solution {
public:
    int minSwaps(string s) {
        int cnt = 0, ans = 0;
        for (auto c: s)
        {
            if (c == '[') cnt ++;
            else if (c == ']') cnt --;
            // cnt 是负数的话，只可能是 -1
            // 因为不平衡后，立刻就将 ] 与最右侧的 [ 互换
            // 这使得相当于遇到了 [ ，则 cnt = 1
            if (cnt == -1)
            {
                cnt = 1;
                ans ++;
            }
        }
        return ans;
    }
};
```

### 找出到每个位置为止最长的有效障碍赛跑路线（最长非降子序列）

你打算构建一些障碍赛跑路线。给你一个 下标从 0 开始 的整数数组 obstacles ，数组长度为 n ，其中 obstacles[i] 表示第 i 个障碍的高度。

对于每个介于 0 和 n - 1 之间（包含 0 和 n - 1）的下标  i ，在满足下述条件的前提下，请你找出 obstacles 能构成的最长障碍路线的长度：

你可以选择下标介于 0 到 i 之间（包含 0 和 i）的任意个障碍。
在这条路线中，必须包含第 i 个障碍。
你必须按障碍在 obstacles 中的 出现顺序 布置这些障碍。
除第一个障碍外，路线中每个障碍的高度都必须和前一个障碍 相同 或者 更高 。
返回长度为 n 的答案数组 ans ，其中 ans[i] 是上面所述的下标 i 对应的最长障碍赛跑路线的长度。

示例 1：

```
输入：obstacles = [1,2,3,2]
输出：[1,2,3,3]
解释：每个位置的最长有效障碍路线是：
- i = 0: [1], [1] 长度为 1
- i = 1: [1,2], [1,2] 长度为 2
- i = 2: [1,2,3], [1,2,3] 长度为 3
- i = 3: [1,2,3,2], [1,2,2] 长度为 3
```

示例 2：

```
输入：obstacles = [2,2,1]
输出：[1,2,1]
解释：每个位置的最长有效障碍路线是：
- i = 0: [2], [2] 长度为 1
- i = 1: [2,2], [2,2] 长度为 2
- i = 2: [2,2,1], [1] 长度为 1
```

示例 3：

```
输入：obstacles = [3,1,5,6,4,2]
输出：[1,1,2,3,2,2]
解释：每个位置的最长有效障碍路线是：
- i = 0: [3], [3] 长度为 1
- i = 1: [3,1], [1] 长度为 1
- i = 2: [3,1,5], [3,5] 长度为 2, [1,5] 也是有效的障碍赛跑路线
- i = 3: [3,1,5,6], [3,5,6] 长度为 3, [1,5,6] 也是有效的障碍赛跑路线
- i = 4: [3,1,5,6,4], [3,4] 长度为 2, [1,4] 也是有效的障碍赛跑路线
- i = 5: [3,1,5,6,4,2], [1,2] 长度为 2
```

提示：
- n == obstacles.length
- 1 <= n <= $10^5$
- 1 <= obstacles[i] <= $10^7$

```cpp
// 最长非降子序列 O(n log n) 单调栈 + 二分
// 维护一个非降的单调栈
// [5,1,5,5,1,3,4,5,1,4] ans[]
// > 5: 5                  1
// > 1: 1                  1
// > 5: 1 5                2
// > 5: 1 5 5              3
// > 1: 1 1 5              2
// > 3: 1 1 3              3
// > 4: 1 1 3 4            4
// > 5: 1 1 3 4 5          5
// > 1: 1 1 1 4 5          3
// > 4: 1 1 1 4 4          5
// 如上，在单调栈中找到左起第一个比自己大的数，取代之
// 单调栈在不断“升级”自己，让自己更加容易作为子序列的一部分

const int MAXN = 1e5 + 10;
int stk[MAXN], top;

class Solution {
public:
    vector<int> longestObstacleCourseAtEachPosition(vector<int>& obstacles) {
        int n = obstacles.size();
        top = 0;
        
        vector<int> ans;
        for (auto t: obstacles)
        {
            // upper_bound() 函数定义在<algorithm>头文件中，
            // 用于在指定范围内查找大于目标值的第一个元素。
            int p = upper_bound(stk + 1, stk + top + 1, t) - stk;  // 为什么从元素 1 开始？因为 top 0 代表没有元素，而非指向第 0 个元素
            ans.push_back(p);
            stk[p] = t;
            top = max(top, p);
        }
        return ans;
    }
};
```
