
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [3413. 收集连续 K 个袋子可以获得的最多硬币数量（滑动窗口+贪心）](#3413-收集连续-k-个袋子可以获得的最多硬币数量滑动窗口贪心)

<!-- /code_chunk_output -->

在四川，没参加。看起来很难，第一名解决时间竟然超过了 30 分钟。

### 3413. 收集连续 K 个袋子可以获得的最多硬币数量（滑动窗口+贪心）

https://leetcode.cn/problems/maximum-coins-from-k-consecutive-bags/description/

```cpp
class Solution {
    // 2271. 毯子覆盖的最多白色砖块数（把右端点对齐）
    long long maximumWhiteTiles(vector<vector<int>>& tiles, int carpetLen) {
        long long ans = 0, cover = 0;
        int left = 0;
        for (auto& tile : tiles) {
            int tl = tile[0], tr = tile[1], c = tile[2];
            cover += (long long) (tr - tl + 1) * c;
            while (tiles[left][1] + carpetLen - 1 < tr) {
                cover -= (long long) (tiles[left][1] - tiles[left][0] + 1) * tiles[left][2];
                left++;
            }
            long long uncover = max((long long) (tr - carpetLen + 1 - tiles[left][0]) * tiles[left][2], 0LL);
            ans = max(ans, cover - uncover);
        }
        return ans;
    }

public:
    long long maximumCoins(vector<vector<int>>& coins, int k) {
        ranges::sort(coins, {}, [](auto& c) { return c[0]; });
        long long ans = maximumWhiteTiles(coins, k);

        // 再把座端点对齐，来一次
        ranges::reverse(coins);
        for (auto& t : coins) {
            int tmp = t[0];
            t[0] = -t[1];
            t[1] = -tmp;
        }
        return max(ans, maximumWhiteTiles(coins, k));
    }
};

作者：灵茶山艾府
链接：https://leetcode.cn/problems/maximum-coins-from-k-consecutive-bags/solutions/3039059/hua-dong-chuang-kou-hua-liang-bian-pytho-4u47/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

为什么不是左对齐就是右对齐？因为最优答案的解集中，一定包含和某个区间对齐的解，所以对这个集合进行遍历是没问题的。
