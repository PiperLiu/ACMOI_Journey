
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [3429. 粉刷房子 IV（记忆化搜索）](#3429-粉刷房子-iv记忆化搜索)

<!-- /code_chunk_output -->

没参加。

### 3429. 粉刷房子 IV（记忆化搜索）

https://leetcode.cn/problems/paint-house-iv/description/

T3 非常典型的记忆化搜索，思路我完全想得到。代码实现看了灵神，思路是一回事，漂亮高效地实现又是另一回事。

```cpp
class Solution {
public:
    long long minCost(int n, vector<vector<int>>& cost) {
        long long memo[n / 2][4][4];  // 为什么是 4 * 4 ？因为第一次要传入 3 “保证一开始的涂色不受约束”
        memset(memo, -1, sizeof(memo)); // -1 表示没有计算过
        auto dfs = [&](this auto&& dfs, int i, int pre_j, int pre_k) -> long long {
            if (i < 0) {
                return 0;
            }
            long long& res = memo[i][pre_j][pre_k]; // 注意这里是引用，这里引用大幅简化了代码
            if (res != -1) { // 之前计算过
                return res;
            }
            res = LLONG_MAX;
            for (int j = 0; j < 3; j++) {
                if (j == pre_j) {
                    continue;
                }
                for (int k = 0; k < 3; k++) {
                    if (k != pre_k && k != j) {
                        res = min(res, dfs(i - 1, j, k) + cost[i][j] + cost[n - 1 - i][k]);
                    }
                }
            }
            return res;
        };
        return dfs(n / 2 - 1, 3, 3);
    }
};


作者：灵茶山艾府
链接：https://leetcode.cn/problems/paint-house-iv/solutions/3051581/duo-wei-dpcong-ji-yi-hua-sou-suo-dao-di-javxs/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
