
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [3424. 将数组变相同的最小代价（贪心）](#3424-将数组变相同的最小代价贪心)

<!-- /code_chunk_output -->

没参加。

### 3424. 将数组变相同的最小代价（贪心）

https://leetcode.cn/problems/minimum-cost-to-make-arrays-identical/description/

T2 乍一看比较复杂。实际上很简单。两个数列都排序后，其元素可以一一对应地变换，是最优的，想到这一点要靠一些直觉，剩下就都好说了。

```cpp
class Solution {
public:
    long long minCost(vector<int>& arr, vector<int>& brr, long long k) {
        int n=arr.size();
        // 不做操作1
        long long res1=0;
        for(int i=0;i<n;++i){
            res1 = res1 + (long long)abs(arr[i]-brr[i]);
        }
        // 做操作1，相当于先把二者排序，元素一一对应
        long long res2=k;
        sort(arr.begin(),arr.end());
        sort(brr.begin(),brr.end());
        for(int i=0;i<n;++i){
            res2 = res2 + (long long)abs(arr[i]-brr[i]);
        }
        return min(res1, res2);
    }
};
```

如上是我的代码。

灵佬的代码一样，他说：用交换论证法可以证明这样做是最优的。
