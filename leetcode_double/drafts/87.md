
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [6186. 按位或最大的最小子数组长度（求出所有子数组的按位或的结果的套路）](#6186-按位或最大的最小子数组长度求出所有子数组的按位或的结果的套路)

<!-- /code_chunk_output -->

没参加。

T4 有种脑筋急转弯的感觉。这次记录 T3 。

### 6186. 按位或最大的最小子数组长度（求出所有子数组的按位或的结果的套路）

给你一个长度为 n 下标从 0 开始的数组 nums ，数组中所有数字均为非负整数。对于 0 到 n - 1 之间的每一个下标 i ，你需要找出 nums 中一个 最小 非空子数组，它的起始位置为 i （包含这个位置），同时有 最大 的 按位或运算值 。

换言之，令 $B_{ij}$ 表示子数组 nums[i...j] 的按位或运算的结果，你需要找到一个起始位置为 i 的最小子数组，这个子数组的按位或运算的结果等于 $\max(B_{ik})$ ，其中 i <= k <= n - 1 。

一个数组的按位或运算值是这个数组里所有数字按位或运算的结果。

请你返回一个大小为 n 的整数数组 answer，其中 answer[i]是开始位置为 i ，按位或运算结果最大，且 最短 子数组的长度。

子数组 是数组里一段连续非空元素组成的序列。

示例 1：
```
输入：nums = [1,0,2,1,3]
输出：[3,3,2,2,1]
解释：
任何位置开始，最大按位或运算的结果都是 3 。
- 下标 0 处，能得到结果 3 的最短子数组是 [1,0,2] 。
- 下标 1 处，能得到结果 3 的最短子数组是 [0,2,1] 。
- 下标 2 处，能得到结果 3 的最短子数组是 [2,1] 。
- 下标 3 处，能得到结果 3 的最短子数组是 [1,3] 。
- 下标 4 处，能得到结果 3 的最短子数组是 [3] 。
所以我们返回 [3,3,2,2,1] 。
```

示例 2：
```
输入：nums = [1,2]
输出：[2,1]
解释：
下标 0 处，能得到最大按位或运算值的最短子数组长度为 2 。
下标 1 处，能得到最大按位或运算值的最短子数组长度为 1 。
所以我们返回 [2,1] 。
```

提示：
- n == nums.length
- 1 <= n <= $10^5$
- 0 <= nums[i] <= $10^9$

```cpp
class Solution {
public:
    // 要注意，从 i 开始，往后累积或，顶多产生 30 个值
    // 因为或过程中 0 能变成 1 ，而 1 不能变成 0
    // 因此最坏情况从 0 开始，顶多到 2^{29} - 1 <= 1e9 （本题范围）
    //
    // 因此我们倒序求，比如 [a, b, c, d, e, f]
    // f 顶多产生 1 个值， [e, f] 顶多产生 2 个值， d 顶多根据 [e, f] 的 2 个值产生 3 个值
    //
    // 对于 i ，可以这么划分以 i 为左端点的子数组:
    // [i, 1, 1, 1, 3, 3, 3, 15, 15, 15]  // 因为或运算中，只能有 0 变成 1
    //     ^  ^  ^  ^  ^  ^  ^   ^   ^  <- 右端点落在对应的累积或值
    vector<int> smallestSubarrays(vector<int> &nums) {
        int n = nums.size();
        vector<int> ans(n);
        vector<pair<int, int>> ors; // 按位或的值 + 对应子数组的右端点的最小值
        for (int i = n - 1; i >= 0; --i) {
            // 把当前 i 值加入到 ors 里， ors 里越后面下标越小
            ors.emplace_back(0, i);
            ors[0].first |= nums[i];
            // 为了去重，用双指针
            // 注意涉及到区间合并，所以不能直接上 set
            int k = 0;
            for (int j = 1; j < ors.size(); ++j) {
                ors[j].first |= nums[i];
                if (ors[k].first == ors[j].first)
                    ors[k].second = ors[j].second; // 合并相同值，下标取最小的
                else ors[++k] = ors[j];
            }
            ors.resize(k + 1);  // 重要！在 C++ 中 resize 可以给 vector 做切片！
            // 本题只用到了 ors[0]，如果题目改成任意给定数字，可以在 ors 中查找
            ans[i] = ors[0].second - i + 1;
        }
        return ans;
    }
};
```

**经验：**
- 在 C++ 中 `resize` 可以给 `vector` 做切片！
